<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动画</title>
    <url>/2019/04/20/Anim/</url>
    <content><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>补间动画是以关键帧以及补间函数组成，在运行时生成当前的动画信息。<br>优点：能利用少量的资源展现丰富的表现, 不会受游戏帧率波动影响。<br>缺点：运行时计算，计算量与动画数量，动画复杂度正相关。<br>优化方向：anim instance 使用 gpu 计算,目前只有骨骼动画适用</p>
<h3 id="补间函数"><a href="#补间函数" class="headerlink" title="补间函数"></a>补间函数</h3><p>根据当前时间计算出动画状态。<br>公式：state = f(t)</p>
<h4 id="常用补间"><a href="#常用补间" class="headerlink" title="常用补间"></a>常用补间</h4><p>模拟自然中的物理规则。<br>匀速运动，加速运动，减速运动<br>p = (P2 - P1) / T * t</p>
<p>物理公式：<br>s = V0 <em> t +  a / 2 </em> t ^ 2</p>
<h4 id="缓动方程"><a href="#缓动方程" class="headerlink" title="缓动方程"></a>缓动方程</h4><p>tween(t, b , c , d)<br>t（time）、b（beforeMove）、c（changeDistance）及d（duration）</p>
<p>X轴 时间<br>Y轴 量</p>
<p>对 x 轴归一化处理<br>X = dx = t / d (0 -&gt; 1)<br>Y = dy (0 -&gt; 1)</p>
<p>构建函数 y = x ^ 2 , y = x ^ 3 …..<br>y = 1 - cos(0.5pi X)<br>y = sin(0.5pi X)</p>
<p>s = b + c * dy</p>
<h4 id="IK"><a href="#IK" class="headerlink" title="IK"></a>IK</h4><p>反向动力学<br>M = Mij * Mpos</p>
<h4 id="骨骼动画"><a href="#骨骼动画" class="headerlink" title="骨骼动画"></a>骨骼动画</h4><p>骨骼，蒙皮，关键帧，补间<br>关键帧存储骨骼的状态信息，骨骼状态信息是矩阵，可参与补间运算。计算出当前时间的骨骼状态后，再更具顶点中记录的权重信息来计算出顶点跟随骨骼运动后的坐标。</p>
<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>以固定帧率播放贴图内容的动画。<br>优点：表现力强，不受限于动画信息的存储。<br>缺点：贴图内容与动画长度正相关。占用大量内存空间, 播放帧率不稳定时，会失真。</p>
<p>优化方向：贴图合批，前期规划。</p>
<h3 id="位图混合"><a href="#位图混合" class="headerlink" title="位图混合"></a>位图混合</h3><p>多张位图混合，控制其中某几张图的滚动形成动画<br>shader 运行时，混合多帧位图。<br>运行时不需要计算帧内容<br>贴图资源大</p>
<h4 id="利用混合让图片内容动起来"><a href="#利用混合让图片内容动起来" class="headerlink" title="利用混合让图片内容动起来"></a>利用混合让图片内容动起来</h4><p>运行时可以通过shader 加入额外的控制参数，动画内容受运行时控制。</p>
<h4 id="噪点的利用"><a href="#噪点的利用" class="headerlink" title="噪点的利用"></a>噪点的利用</h4><p>噪点图的参数，在随机性上更自然。 贴图可进入 GPU 运算，效率更佳。</p>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>播放，帧率</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>anim = controlPoint + f(t)</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>AssetBundle序列化尺寸</title>
    <url>/2020/06/23/AssetBundle%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%BA%E5%AF%B8/</url>
    <content><![CDATA[<h1 id="AssetBundle-加载进内存的序列化文件分析"><a href="#AssetBundle-加载进内存的序列化文件分析" class="headerlink" title="AssetBundle 加载进内存的序列化文件分析"></a>AssetBundle 加载进内存的序列化文件分析</h1><h2 id="Asset-AssetBundle-序列化分析"><a href="#Asset-AssetBundle-序列化分析" class="headerlink" title="Asset AssetBundle 序列化分析"></a>Asset AssetBundle 序列化分析</h2><hr>
<h3 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h3><p>纹理大小不一样<br>|AssetBundle|TextureSize| AssetBundleSize|SerializedFileSize|<br>|—|—|—|—|<br>|texture1|512 <em> 512| 176 KB |18.0 KB |<br>|texture2|1024 </em> 1024| 688 KB |18.0 KB |</p>
<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p>以拷贝出来的的 Standard Shader 为标准，分别增加其 Properties 和 SubShader<br>|AssetBundle|ShaderInfo| AssetBundleSize|SerializedFileSize|<br>|—|—|—|—|<br>|shader1|Copy From Standard| 110 KB | <strong>121.6 KB</strong> |<br>|shader2|+ 40 Properties| 113 KB| <strong>121.6 KB</strong> |<br>|shader3|+ 20 SubShader| 519 KB |<strong>121.6 KB</strong> |</p>
<h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><p>顶点数量不同<br>|AssetBundle| MeshInfo |AssetBundleSize|SerializedFileSize|<br>|—|—|—|—|<br>|mesh1| 0 verts 0 tris |9 KB| <strong>23.2 KB</strong> |<br>|mesh2| 30000 verts 10000 tris| 419 KB| <strong>23.2 KB</strong> |</p>
<blockquote>
<p>Asset 打包进行 AssetBundle 的序列化文件，并不受资源内容尺寸影响，只与资源类型相关</p>
</blockquote>
<hr>
<h3 id="复数资源的打包"><a href="#复数资源的打包" class="headerlink" title="复数资源的打包"></a>复数资源的打包</h3><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Group</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>group1</td>
<td>Texture1 + Mesh1 + Shader1</td>
<td>289 KB</td>
<td><strong>129.4 KB</strong></td>
</tr>
<tr>
<td>group2</td>
<td>Texture1 + Texture2 + Mesh1 + Mesh2 + Shader1 + Shader2</td>
<td>1461 KB</td>
<td><strong>129.5 KB</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>同类资源打包, 并不等于单个资源序列化后的文件之和，而是小于，推测有过一些压缩的方案。</li>
<li>重复资源打包，增长量为 0.1KB , 推断同类型资源不会重复创建序列化文件， 增长的 0.1KB 应该是引用相关的数据</li>
</ul>
</blockquote>
<h2 id="Prefab-AssetBundle-序列化分析"><a href="#Prefab-AssetBundle-序列化分析" class="headerlink" title="Prefab AssetBundle 序列化分析"></a>Prefab AssetBundle 序列化分析</h2><h3 id="Prefab-序列化尺寸"><a href="#Prefab-序列化尺寸" class="headerlink" title="Prefab 序列化尺寸"></a>Prefab 序列化尺寸</h3><p>空 Prefab<br>复数空 Prefab 尺寸<br>|AssetBundle| Info |AssetBundleSize|SerializedFileSize|<br>|—|—|—|—|<br>| prefab1| 空的 Gameobject | 5 KB | <strong>18.3 KB</strong> |<br>| prefabgroup | 100 个 空 Gameobject | 30 KB | <strong>23 KB</strong> |</p>
<blockquote>
<p>100 个 Prefab 打包相比单个 Prefab ，增长量为 1.7 KB , 复数的 Prefab 合并打包不会创建重复的序列化文件</p>
</blockquote>
<h3 id="Prefab-复杂化后的尺寸"><a href="#Prefab-复杂化后的尺寸" class="headerlink" title="Prefab 复杂化后的尺寸"></a>Prefab 复杂化后的尺寸</h3><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Info</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefab1</td>
<td>空的 Gameobject</td>
<td>5 KB</td>
<td><strong>18.3 KB</strong></td>
</tr>
<tr>
<td>prefab2</td>
<td>深度创建 1000 个 Child</td>
<td>192 KB</td>
<td><strong>65.2 KB</strong></td>
</tr>
<tr>
<td>prefab3</td>
<td>广度创建 1000 个 Child</td>
<td>197 KB</td>
<td><strong>67.0 KB</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>1000 个 Gameobject 嵌套创建后相比空的 GameObject ，增长量为 46.9 KB ，广度嵌套相比增长再多 1.8 KB 。 对比上一个空 prefab 的测试， 100 个 prefab 增长约 5KB , 这里 1000 个 child 对应增长  46.9 KB 。Prefab 的复杂度增加也会增大序列化文件的尺寸</p>
</blockquote>
<h2 id="MonoScript-AssetBundle-序列化尺寸"><a href="#MonoScript-AssetBundle-序列化尺寸" class="headerlink" title="MonoScript AssetBundle 序列化尺寸"></a>MonoScript AssetBundle 序列化尺寸</h2><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Info</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>mono1</td>
<td>干净的 MonoScript</td>
<td>6 KB</td>
<td><strong>20.1 KB</strong></td>
</tr>
<tr>
<td>mono2</td>
<td>+ 10 Vector3[] 序列化字段</td>
<td>7 KB</td>
<td><strong>20.8 KB</strong></td>
</tr>
<tr>
<td>mono3</td>
<td>每个序列化字段填入100个 vector3</td>
<td>19 KB</td>
<td><strong>20.8 KB</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>脚本的序列化只与序列化字段的的数量有关，字段内容并不被提前序列化后加载</p>
</blockquote>
<h2 id="AssetBundle-中依赖关系的序列化分析"><a href="#AssetBundle-中依赖关系的序列化分析" class="headerlink" title="AssetBundle 中依赖关系的序列化分析"></a>AssetBundle 中依赖关系的序列化分析</h2><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Info</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>reference1</td>
<td>GameObject + Mono</td>
<td>6 KB</td>
<td><strong>20.2 KB</strong></td>
</tr>
<tr>
<td>reference2</td>
<td>GameObject + Mono + Texture</td>
<td>178 KB</td>
<td><strong>21.6 KB</strong></td>
</tr>
<tr>
<td>reference3</td>
<td>GameObject + Mono -&gt; Texture</td>
<td>178 KB</td>
<td><strong>21.6 KB</strong></td>
</tr>
<tr>
<td>reference4</td>
<td>GameObject + Mono -&gt; Texture(texture1)</td>
<td>6 KB</td>
<td><strong>92.3 KB</strong></td>
</tr>
<tr>
<td>reference4</td>
<td>GameObject + Mono -&gt; Texture1(texture1) Texture2(texture2)</td>
<td>6 KB</td>
<td><strong>92.4 KB</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>包内依赖与包内引用没有大小的变化，推断引用关系不会被序列化或者是量级太小无法感知</li>
<li>包之间的引用产生了一个 70.7 KB 的变化，这个变化不会随着包的引用数量而增加，查资料发现是有一个extern reference 的 buff 区域创建。 </li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>AssetBundle序列化文件分析</title>
    <url>/2020/06/19/AssetBundle%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>AssetBundle 在被加载后，不管通过何种方式加载，都会创建一个 AssetBundle 的 SerializedFile。 本文尝试对其 Size 受那些因素影响进行分析。</p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="资源大小"><a href="#资源大小" class="headerlink" title="资源大小"></a>资源大小</h2><p>分别创建两个大小不同的贴图 Texture1 和 Texture2 分别打进 texture1 和 texture2 两个 ab 包中，加载后对比 Size</p>
<table>
<thead>
<tr>
<th style="text-align:center">AssetBundle</th>
<th style="text-align:center">TextureSize</th>
<th style="text-align:center">FileSize</th>
<th style="text-align:center">ChangeSize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">texture1</td>
<td style="text-align:center">512 x 512</td>
<td style="text-align:center">18.0 KB</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">texture2</td>
<td style="text-align:center">1024 x 1024</td>
<td style="text-align:center">18.0 KB</td>
<td style="text-align:center">0KB</td>
</tr>
</tbody>
</table>
<blockquote>
<p>两者没有变化，File 不受原始素材大小影响</p>
</blockquote>
<h2 id="Shader-类型"><a href="#Shader-类型" class="headerlink" title="Shader 类型"></a>Shader 类型</h2><p>创建创建使用两个不同 Shader 的 Material， 加载后对比</p>
<table>
<thead>
<tr>
<th style="text-align:center">AssetBundle</th>
<th style="text-align:center">Shader</th>
<th style="text-align:center">FileSize</th>
<th style="text-align:center">ChangeSize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mat1</td>
<td style="text-align:center">Standard</td>
<td style="text-align:center">123.9 KB</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">mat2</td>
<td style="text-align:center">Legacy</td>
<td style="text-align:center">123.9 KB</td>
<td style="text-align:center">0KB</td>
</tr>
</tbody>
</table>
<blockquote>
<p>两者没有变化，File 不受 Shader 类型影响</p>
</blockquote>
<h2 id="多个-Assets"><a href="#多个-Assets" class="headerlink" title="多个 Assets"></a>多个 Assets</h2><table>
<thead>
<tr>
<th style="text-align:center">Assets</th>
<th style="text-align:center">FileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">texture1</td>
<td style="text-align:center">18.0 KB</td>
</tr>
<tr>
<td style="text-align:center">texture2</td>
<td style="text-align:center">18.0 KB</td>
</tr>
<tr>
<td style="text-align:center">mat1</td>
<td style="text-align:center">123.9 KB</td>
</tr>
<tr>
<td style="text-align:center">mat2</td>
<td style="text-align:center">123.9 KB</td>
</tr>
<tr>
<td style="text-align:center">texture1 + mat1</td>
<td style="text-align:center">125.2 KB</td>
</tr>
<tr>
<td style="text-align:center">texture1 + texture2 + mat1 + mat2</td>
<td style="text-align:center">125.3 KB</td>
</tr>
</tbody>
</table>
<blockquote>
<p>FileSize 只受包内 Asset 类型的影响与数量无关</p>
</blockquote>
<h2 id="组件类型"><a href="#组件类型" class="headerlink" title="组件类型"></a>组件类型</h2><p>创建多个 prefab 并，组个增加不同的组件，进行对比</p>
<table>
<thead>
<tr>
<th style="text-align:center">AssetBundle</th>
<th style="text-align:left">Component Change</th>
<th style="text-align:center">FileSize</th>
<th style="text-align:center">ChangeSize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">prefab1</td>
<td style="text-align:left">+ GameObject</td>
<td style="text-align:center">18.3 KB</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">prefab2</td>
<td style="text-align:left">+ MeshColider</td>
<td style="text-align:center">19.0 KB</td>
<td style="text-align:center">0.7 KB</td>
</tr>
<tr>
<td style="text-align:center">prefab3</td>
<td style="text-align:left">+ capsule</td>
<td style="text-align:center">91.0 KB</td>
<td style="text-align:center">72 KB</td>
</tr>
<tr>
<td style="text-align:center">prefab4</td>
<td style="text-align:left">+ MeshRender</td>
<td style="text-align:center">92.7 KB</td>
<td style="text-align:center">1.7 KB</td>
</tr>
<tr>
<td style="text-align:center">prefab5</td>
<td style="text-align:left">+ mat2</td>
<td style="text-align:center">92.8 KB</td>
<td style="text-align:center">0.1 KB</td>
</tr>
<tr>
<td style="text-align:center">prefab5</td>
<td style="text-align:left">capsule -&gt; cube</td>
<td style="text-align:center">92.8 KB</td>
<td style="text-align:center">0 KB</td>
</tr>
<tr>
<td style="text-align:center">prefab5</td>
<td style="text-align:left">+ mat1</td>
<td style="text-align:center">92.8 KB</td>
<td style="text-align:center">0 KB</td>
</tr>
<tr>
<td style="text-align:center">prefab5</td>
<td style="text-align:left">+ MonoScript1 (2 kb)</td>
<td style="text-align:center">94.7 KB</td>
<td style="text-align:center">1.9 KB</td>
</tr>
</tbody>
</table>
<p>refab5|+ MonoScript2 (1 kb) | 95.3 KB|  0.6 KB|</p>
<ol>
<li>每次增加新的组件都会增加 Size</li>
<li>资源的引入<ul>
<li>capsule 资源的引入增加了大量 Size 变化</li>
<li>capsule 替换成 Cube 并没有 Size 变化<blockquote>
<p>新增类型的引入造成了 Size 的变化。</p>
</blockquote>
</li>
</ul>
</li>
<li>AssetBundle 资源引入<ul>
<li>mat2 bundle 内容的资源引入增长量与mat2 bundle 的 FileSzie 不相符</li>
<li>再次引入相同类型的资源 mat1 , 未增长<blockquote>
<p>Bundle 类型的引入对 Size 影响非常小，且不受数量影响</p>
</blockquote>
</li>
</ul>
</li>
<li>引入 MonoScript<ul>
<li>Scirpt 每次引入都会增长 Size</li>
<li>Size 的增长与引入脚本的大小正相关</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AssetBundle 加载后创建的 SerializeFiled 受包体内资源类型的数量影响，Asset 的资源类型数量有限，并不会无限增长。需要注意的是 FileSize 的大小与 MonoScript 的大小，数量正相关，需要在打包时关注。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>AssetBundle研究报告</title>
    <url>/2020/06/24/AssetBundle%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="AssetBundle-文件结构"><a href="#AssetBundle-文件结构" class="headerlink" title="AssetBundle 文件结构"></a>AssetBundle 文件结构</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="The-AssetBundle-File"><a href="#The-AssetBundle-File" class="headerlink" title="The AssetBundle File"></a>The AssetBundle File</h3><p>AssetBundle File 是一个包含多个文件的 <strong>Archive</strong> , 其结构会有一些小的变化取决于是 normal AssetBundle 还是 Scene AssetBundle</p>
<p>Normal AssetBundle<br><img src="/2020/06/24/AssetBundle研究报告/1.png" class="Normal AssetBundle Structure"></p>
<p>Scene AssetBundle<br><img src="/2020/06/24/AssetBundle研究报告/2.png" class="Scene AssetBundle Structure"><br>　场景包还包含了预加载数据（PreloadData）、共享数据（shaderData）和全局光照数据（Global Illumination Data）并且针对场景及其内容的 Stream Loading 进行了优化</p>
<h3 id="The-Manifest-File"><a href="#The-Manifest-File" class="headerlink" title="The Manifest File"></a>The Manifest File</h3><p>对于每个生成的 AssetBundle 都会有对应的 Manifest Bundle 生成。 文件内容以文本格式存储，可被任何文本编辑器打开。<br>Manifest文件仅用于检查增量构建，运行时不需要。因此不需要打包进正式发行的游戏中。<br>每个AssetBundle都有一个manifest文件，包含如下信息：</p>
<ul>
<li>CRC（循环冗余码）：资源文件的哈希码，在该AssetBundle中的所有资源有一个单一的哈希码，用于检查增量的构建。</li>
<li>Type tree哈希码：在该AssetBundle中所有类型有一个单一的哈希码，用于检查增量的构建。</li>
<li>Class types：该AssetBundle中所有的类类型。当为type tree做增量构建检查时将产生一个新的哈希码。</li>
<li>Assets：该AssetBundle中所有明确包含的资源名字，依赖于该AssetBundle的其他AssetBundle。</li>
<li>Dependencies： 依赖列表</li>
</ul>
<p>文件内容大体如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ManifestFileVersion: 0</span><br><span class="line">CRC: 2422268106</span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 8b6db55a2344f068cf8a9be0a662ba15</span><br><span class="line">  TypeTreeHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 37ad974993dbaa77485dd2a0c38f347a</span><br><span class="line">HashAppended: 0</span><br><span class="line">ClassTypes:</span><br><span class="line">- Class: 91</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Mecanim/StateMachine.controller</span><br><span class="line">Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件结构分析"><a href="#文件结构分析" class="headerlink" title="文件结构分析"></a>文件结构分析</h2><p>把压缩数据解开后，就和非压缩模式没有差别，下面只讨论非压缩格式:</p>
<p>AssetBundle由两部分组成：Header 和 DataSegment</p>
<ul>
<li>Header 中保存了版本号，数据类型，文件信息，等描述信息。其中文件信息记录了单个资源文件的描述信息以及文件的 offset 和 size。<br>文件信息记录了数据部分里面的所有单个资源的文件名以及在整个AssetBundle中<br>文件offset和size,通过这个信息可以直接获取到AssetBundle中的某一个文件的数据。  </li>
<li>DataSegment 保存着实际的 Asset 文件内容</li>
</ul>
<p>文件头结构如下图：</p>
<img src="/2020/06/24/AssetBundle研究报告/5.png" class="AssetBundle Compreesion File">
<p>具体的序列化结构如下：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里，所有的 int 都是以小端编码的 4 字节整数（不同于外部文件格式采用的大端编码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AssetBundle文件头结构</span></span><br><span class="line"><span class="keyword">struct</span> AssetBundleFileHead &#123;</span><br><span class="line">     <span class="keyword">struct</span> LevelInfo &#123;</span><br><span class="line">         unsigned <span class="keyword">int</span> PackSize;</span><br><span class="line">         unsigned <span class="keyword">int</span> UncompressedSize;</span><br><span class="line">     &#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">string</span> FileID;</span><br><span class="line">     unsigned <span class="keyword">int</span> Version; <span class="comment">// bundle格式版本 3.5~4.x : Version == 3</span></span><br><span class="line">     <span class="keyword">string</span> MainVersion; <span class="comment">// </span></span><br><span class="line">     <span class="keyword">string</span> BuildVersion;</span><br><span class="line">     size_t MinimumStreamedBytes;</span><br><span class="line">     size_t HeaderSize;</span><br><span class="line">     size_t NumberOfLevelsToDownloadBeforeStreaming;</span><br><span class="line">     size_t LevelCount;</span><br><span class="line">     LevelInfo LevelList[];</span><br><span class="line">     size_t CompleteFileSize;</span><br><span class="line">     size_t FileInfoHeaderSize;</span><br><span class="line">     <span class="keyword">bool</span> Compressed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> AssetFileHeader &#123;</span><br><span class="line">     <span class="keyword">struct</span> AssetFileInfo &#123;</span><br><span class="line">          <span class="keyword">string</span> name;</span><br><span class="line">          size_t offset; <span class="comment">//表示的是除去 HeaderSize 后的偏移量</span></span><br><span class="line">          size_t length;</span><br><span class="line">     &#125;;</span><br><span class="line">     size_t FileCount; <span class="comment">// 大多数情况只有一个</span></span><br><span class="line">     AssetFileInfo     File[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> AssetHeader &#123;</span><br><span class="line">    <span class="comment">// TypeTree 是对数据结构本身的描述，通过这个描述，就可以反序列化出每个对象</span></span><br><span class="line">    <span class="comment">//这个 TypeTree 对于 asset bundle 来说是可选的，因为数据结构的信息可以事先放置在引擎中（引擎多半只支持固有的数据类型）。在发布到移动设备上时，TypeTree 是不打包到 asset bundle 中的。</span></span><br><span class="line">     size_t TypeTreeSize; <span class="comment">// TypeTree 部分的大小</span></span><br><span class="line">     size_t FileSize;</span><br><span class="line">     unsigned <span class="keyword">int</span> Format;</span><br><span class="line">     size_t dataOffset;</span><br><span class="line">     size_t Unknown;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ObjectHeader &#123;</span><br><span class="line">     <span class="keyword">struct</span> ObjectInfo &#123;</span><br><span class="line">          <span class="keyword">int</span> pathID; <span class="comment">// 每个对象都有唯一的字符串 path ，但是在 asset bundle 里并没有直接保存字符串，而是一个 hash 过的整数</span></span><br><span class="line">          <span class="keyword">int</span> offset; <span class="comment">// 相对当前 asset 块的</span></span><br><span class="line">          <span class="keyword">int</span> length;</span><br><span class="line">          <span class="keyword">byte</span> classID[<span class="number">8</span>]; <span class="comment">// Class ID的和具体类型的对应关系，在 Unity3d 的官方文档 可以查到。</span></span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">int</span> ObjectCount;</span><br><span class="line">     ObjectInfo Object[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> AssetTable &#123;</span><br><span class="line">     <span class="keyword">struct</span> AssetRef &#123;</span><br><span class="line">          <span class="keyword">byte</span> GUID[<span class="number">8</span>];</span><br><span class="line">          <span class="keyword">int</span> type;</span><br><span class="line">          <span class="keyword">string</span> filePath;</span><br><span class="line">          <span class="keyword">string</span> assetPath;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">int</span> Count;</span><br><span class="line">     <span class="keyword">byte</span> Unknown;</span><br><span class="line">    vector Refs;</span><br></pre></td></tr></table></figure></p>
<h2 id="压缩方案"><a href="#压缩方案" class="headerlink" title="压缩方案"></a>压缩方案</h2><p>AssetBundle 压缩后的大致文件组成：<br><img src="/2020/06/24/AssetBundle研究报告/3.png" class="AssetBundle Compreesion File"></p>
<p>Unity 在打包 AssetBundle 时会默认以 LZMA 格式进行压缩，可以通过 <strong>BuildAssetBundleOptions</strong> 调整压缩方案。  </p>
<ul>
<li>BuildAssetBundleOptions.None(LZMA):<br>此选项会使用 LZMA 格式压缩成序列化文件流。LZMA 的优点是打包体积小，缺点是使用时需要整体解包，导致加载时间长。</li>
<li>BuildAssetBundleOptions.UncompressedAssetBundle<br>此选项不会对文件进行压缩，优点是加载不需要解包速度快，缺点是打包体积大。</li>
<li>BueldAssetBundleOptions.ChunkBasedCompression(LZ4)<br>此选项会以 LZ4 的格式进行压缩，LZ4 是一种基于 chunk 的算法，该算法运行 Bundle 进行分块（chunk）式加载，只解压缩单个需要使用的资产。</li>
</ul>
<h1 id="AssetBundle-加载时的存储方案"><a href="#AssetBundle-加载时的存储方案" class="headerlink" title="AssetBundle 加载时的存储方案"></a>AssetBundle 加载时的存储方案</h1><p>Bundle 加载后，分为两部分存储，</p>
<ul>
<li>一部分是头文件，以 SerializedFile 格式存储在内存中，</li>
<li>另一部分则是 AssetBundle Content ，依据不同的加载的方式存储在内存或者磁盘中。</li>
</ul>
<h2 id="不同压缩方案的加载-API-对比："><a href="#不同压缩方案的加载-API-对比：" class="headerlink" title="不同压缩方案的加载 API 对比："></a>不同压缩方案的加载 API 对比：</h2><table>
<thead>
<tr>
<th>API</th>
<th>UnCompressed</th>
<th>LZ4(ChunkBasedCompression)</th>
<th>LZMA(Stream Compression)</th>
</tr>
</thead>
<tbody>
<tr>
<td>www</td>
<td>内存：未压缩，内存读取</td>
<td>内存：LZ4HC压缩，内存读取</td>
<td>内存：LZ4压缩，内存读取</td>
</tr>
<tr>
<td>LoadFromCacheOrDownload</td>
<td>内存：无，硬盘直读</td>
<td>内存：无，硬盘直读</td>
<td>内存：无，硬盘直读</td>
</tr>
<tr>
<td>LoadFromMemory(Async)</td>
<td>内存：未压缩</td>
<td>内存：LZ4HC压缩</td>
<td>内存：LZ4压缩，LZMA解压 -&gt; LZ4压缩</td>
</tr>
<tr>
<td>LoadFromFile(Async)</td>
<td>内存：无，硬盘直读</td>
<td>内存：无，硬盘直读</td>
<td>内存：LZ4压缩 ，硬盘读取 -&gt; LZMA解压 -&gt; LZ4压缩 -&gt; 内存读取</td>
</tr>
<tr>
<td>WebRequest</td>
<td>内存：无，Cache直读</td>
<td>内存：无，Cache直读</td>
<td>内存：无，LZMA解压 -&gt; LZ4压缩</td>
</tr>
</tbody>
</table>
<h1 id="AsetBundle-加载后的内存分析"><a href="#AsetBundle-加载后的内存分析" class="headerlink" title="AsetBundle 加载后的内存分析"></a>AsetBundle 加载后的内存分析</h1><img src="/2020/06/24/AssetBundle研究报告/4.png" class="AssetBundle 内存分析">
<h2 id="SerializedFile-分析"><a href="#SerializedFile-分析" class="headerlink" title="SerializedFile 分析"></a>SerializedFile 分析</h2><blockquote>
<p>分别制作干净的 AssetBundle 包，加载进内存，通过 Profile 抓取内存分析大小并对比。Unity 版本 2017.4.x</p>
</blockquote>
<h3 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h3><p>纹理大小不一样  </p>
<table>
<thead>
<tr>
<th>AssetBundle</th>
<th>TextureSize</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>texture1</td>
<td>512 x 512</td>
<td>176 KB</td>
<td>18.0 KB</td>
</tr>
<tr>
<td>texture2</td>
<td>1024 x 1024</td>
<td>688 KB</td>
<td>18.0 KB</td>
</tr>
</tbody>
</table>
<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p>以拷贝出来的的 Standard Shader 为标准，分别增加其 Properties 和 SubShader  </p>
<table>
<thead>
<tr>
<th>AssetBundle</th>
<th>ShaderInfo</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>shader1</td>
<td>Copy From Standard</td>
<td>110 KB</td>
<td><strong>121.6 KB</strong></td>
</tr>
<tr>
<td>shader2</td>
<td>+ 40 Properties</td>
<td>113 KB</td>
<td><strong>121.6 KB</strong></td>
</tr>
<tr>
<td>shader3</td>
<td>+ 20 SubShader</td>
<td>519 KB</td>
<td><strong>121.6 KB</strong></td>
</tr>
</tbody>
</table>
<h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><p>顶点数量不同  </p>
<table>
<thead>
<tr>
<th>AssetBundle</th>
<th>MeshInfo</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>mesh1</td>
<td>0 verts 0 tris</td>
<td>9 KB</td>
<td><strong>23.2 KB</strong></td>
</tr>
<tr>
<td>mesh2</td>
<td>30000 verts 10000 tris</td>
<td>419 KB</td>
<td><strong>23.2 KB</strong></td>
</tr>
</tbody>
</table>
<p>Asset 打包进行 AssetBundle 的序列化文件，并不受资源内容尺寸影响，只与资源类型相关</p>
<h3 id="复数资源的打包"><a href="#复数资源的打包" class="headerlink" title="复数资源的打包"></a>复数资源的打包</h3><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Group</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>group1</td>
<td>Texture1 + Mesh1 + Shader1</td>
<td>289 KB</td>
<td><strong>129.4 KB</strong></td>
</tr>
<tr>
<td>group2</td>
<td>Texture1 + Texture2 + Mesh1 + Mesh2 + Shader1 + Shader2</td>
<td>1461 KB</td>
<td><strong>129.5 KB</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>同类资源打包, 并不等于单个资源序列化后的文件之和，而是小于，推测有过一些压缩的方案。</li>
<li>重复资源打包，增长量为 0.1KB , 推断同类型资源不会重复创建序列化文件， 增长的 0.1KB 应该是引用相关的数据</li>
</ul>
<hr>
<h3 id="Prefab-序列化尺寸"><a href="#Prefab-序列化尺寸" class="headerlink" title="Prefab 序列化尺寸"></a>Prefab 序列化尺寸</h3><p>空 Prefab<br>复数空 Prefab 尺寸  </p>
<table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Info</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefab1</td>
<td>空的 Gameobject</td>
<td>5 KB</td>
<td><strong>18.3 KB</strong></td>
</tr>
<tr>
<td>prefabgroup</td>
<td>100 个 空 Gameobject</td>
<td>30 KB</td>
<td><strong>23 KB</strong></td>
</tr>
</tbody>
</table>
<p>100 个 Prefab 打包相比单个 Prefab ，增长量为 1.7 KB , 复数的 Prefab 合并打包不会创建重复的序列化文件</p>
<h3 id="Prefab-复杂化后的尺寸"><a href="#Prefab-复杂化后的尺寸" class="headerlink" title="Prefab 复杂化后的尺寸"></a>Prefab 复杂化后的尺寸</h3><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Info</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefab1</td>
<td>空的 Gameobject</td>
<td>5 KB</td>
<td><strong>18.3 KB</strong></td>
</tr>
<tr>
<td>prefab2</td>
<td>深度创建 1000 个 Child</td>
<td>192 KB</td>
<td><strong>65.2 KB</strong></td>
</tr>
<tr>
<td>prefab3</td>
<td>广度创建 1000 个 Child</td>
<td>197 KB</td>
<td><strong>67.0 KB</strong></td>
</tr>
</tbody>
</table>
<p>1000 个 Gameobject 嵌套创建后相比空的 GameObject ，增长量为 46.9 KB ，广度嵌套相比增长再多 1.8 KB 。 对比上一个空 prefab 的测试， 100 个 prefab 增长约 5KB , 这里 1000 个 child 对应增长  46.9 KB 。Prefab 的复杂度增加也会增大序列化文件的尺寸</p>
<h2 id="MonoScript-AssetBundle-序列化尺寸"><a href="#MonoScript-AssetBundle-序列化尺寸" class="headerlink" title="MonoScript AssetBundle 序列化尺寸"></a>MonoScript AssetBundle 序列化尺寸</h2><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Info</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>mono1</td>
<td>干净的 MonoScript</td>
<td>6 KB</td>
<td><strong>20.1 KB</strong></td>
</tr>
<tr>
<td>mono2</td>
<td>+ 10 Vector3[] 序列化字段</td>
<td>7 KB</td>
<td><strong>20.8 KB</strong></td>
</tr>
<tr>
<td>mono3</td>
<td>每个序列化字段填入100个 vector3</td>
<td>19 KB</td>
<td><strong>20.8 KB</strong></td>
</tr>
</tbody>
</table>
<p>脚本的序列化只与序列化字段的的数量有关，字段内容并不被提前序列化后加载</p>
<h2 id="AssetBundle-中依赖关系的序列化分析"><a href="#AssetBundle-中依赖关系的序列化分析" class="headerlink" title="AssetBundle 中依赖关系的序列化分析"></a>AssetBundle 中依赖关系的序列化分析</h2><table>
<thead>
<tr>
<th>AssetBundle</th>
<th>Info</th>
<th>AssetBundleSize</th>
<th>SerializedFileSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>reference1</td>
<td>GameObject + Mono</td>
<td>6 KB</td>
<td><strong>20.2 KB</strong></td>
</tr>
<tr>
<td>reference2</td>
<td>GameObject + Mono + Texture</td>
<td>178 KB</td>
<td><strong>21.6 KB</strong></td>
</tr>
<tr>
<td>reference3</td>
<td>GameObject + Mono -&gt; Texture</td>
<td>178 KB</td>
<td><strong>21.6 KB</strong></td>
</tr>
<tr>
<td>reference4</td>
<td>GameObject + Mono -&gt; Texture(texture1)</td>
<td>6 KB</td>
<td><strong>92.3 KB</strong></td>
</tr>
<tr>
<td>reference4</td>
<td>GameObject + Mono -&gt; Texture1(texture1) Texture2(texture2)</td>
<td>6 KB</td>
<td><strong>92.4 KB</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>包内依赖与包内引用没有大小的变化，推断引用关系不会被序列化或者是量级太小无法感知</li>
<li>包之间的引用产生了一个 70.7 KB 的变化，这个变化不会随着包的引用数量而增加</li>
</ul>
<p>网络上查了以下资料， Unity 在 Unit2018 大会上对 SerializedFile 文件大小有过讲解，细节如下：</p>
<blockquote>
<p>其实SerializedFile记录着重建资源所需的信息。而其大体的组成是有2 x 7KB的文件读取Buffer，较大的TypeTree占用，如果存有外部引用，会有一个最少72KB的External References的Buffer，剩下的就是我们资源的数据了，我们会在后续版本把External References的内存占用降到4KB+</p>
<p>Profiler 内 SerializedFile 大体组成 (Unity 2017.4.1f Mobile &amp; Editor)</p>
<ul>
<li>14Kb File Read Cache</li>
<li>(较大) TypeTree</li>
<li>72KB External References</li>
<li>(较小，与 AB 内 Object 数量相关) Object Map &amp; Infos  </li>
</ul>
<p><a href="https://connect.unity.com/p/unite-2018-jie-xi-assetbundle" target="_blank" rel="noopener">原文地址</a>  </p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>除了为了极短的减少包体尺寸 LZ4 的压缩格式在内存的额外占用，包体的大小，加载的时间上都有一定的优化能力，是一个不错的选择方案。</li>
<li>从 SerializedFile 文件大小的分析可知，在分包策略上需要更多的考虑合包的可能性，否则容易造成复数的 External Refernce Buff 区域创建，造成内存的浪费。</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://blog.codingnow.com/2014/08/unity3d_asset_bundle.html" target="_blank" rel="noopener">Unity3D asset bundle 格式简析</a><br><a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">ClassIDReference</a><br><a href="https://connect.unity.com/p/unite-2018-jie-xi-assetbundle" target="_blank" rel="noopener">Unite 2018 | 解析AssetBundle</a><br><a href="https://www.cnblogs.com/pinkfloyd/p/6489979.html" target="_blank" rel="noopener">AssetBundle文件结构浅析</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>AssetBundle简析</title>
    <url>/2020/06/18/AssetBundle%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<h1 id="AssetBundle-加载流程"><a href="#AssetBundle-加载流程" class="headerlink" title="AssetBundle 加载流程"></a>AssetBundle 加载流程</h1><p>加载流程可归纳为以下两种</p>
<ul>
<li>从目标路径读取并创建 AssetBundle 对象 <blockquote>
<p>目标可存在远端服务器，也可是本地磁盘</p>
</blockquote>
</li>
<li>从 AssetBundle 对象中创建 Asset</li>
</ul>
<h2 id="加载-AssetBundle-对象的几种方式与区别"><a href="#加载-AssetBundle-对象的几种方式与区别" class="headerlink" title="加载 AssetBundle 对象的几种方式与区别"></a>加载 AssetBundle 对象的几种方式与区别</h2><p>说到加载，必须了解 AssetBundle 在运行时的存储方案。 Bundle 分为两部分存储，一部分是包含 Bundle 概览的头文件，以 SerializedFile 格式存储在内存中，另一部分则是 Bundle Content ，会更根据加载的方式以流的方式存储在内存或者磁盘中。<br><img src="/2020/06/18/AssetBundle简析/3.png" class="SerializedFile"></p>
<p>根据文档 AssetBundle 的加载有以下几种方式</p>
<h3 id="wwww-assetBundle"><a href="#wwww-assetBundle" class="headerlink" title="wwww.assetBundle"></a>w<a href="http://www.assetBundle" target="_blank" rel="noopener">www.assetBundle</a></h3><ul>
<li>通过 www 对象加载 url 地址所在的 ab 包，此方法会在内存中创建一块 webstream 用于保存 bundle</li>
<li><a href="http://www.LoadFromCacheOrDownload" target="_blank" rel="noopener">www.LoadFromCacheOrDownload</a> 加载 bundle 文件并将 bundle 内容以解压的格式存入磁盘作为缓存,后续的 Load 通过 IO 从磁盘读取。</li>
</ul>
<h3 id="AssetBundle-LoadFromFile-Async"><a href="#AssetBundle-LoadFromFile-Async" class="headerlink" title="AssetBundle.LoadFromFile(Async)"></a>AssetBundle.LoadFromFile(Async)</h3><p>从磁盘路径读取 AssetBundle 文件，如果文件内容是以 LZMA 格式压缩的，则会将内容解压进内存保存。未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会通过 IO 从磁盘读取。</p>
<p>LZMA 格式加载后内存增长 4.4MB<br><img src="/2020/06/18/AssetBundle简析/1.png" class="LZMA"><br>LZ4 格式加载后内存增长 0.5MB<br><img src="/2020/06/18/AssetBundle简析/2.png" class="LZ4"><br>NO COMPRESSION 加载后内存增长 0.1MB<br><img src="/2020/06/18/AssetBundle简析/4.png" class="NO compression"></p>
<h3 id="AssetBundle-LoadFromMemory-Async"><a href="#AssetBundle-LoadFromMemory-Async" class="headerlink" title="AssetBundle.LoadFromMemory(Async)"></a>AssetBundle.LoadFromMemory(Async)</h3><p>从内存的 byets 数据中创建 bundle 内容， 适用于需要对原始数据进行解密的方式。</p>
<h3 id="AssetBundle-LoadFromStream-Async"><a href="#AssetBundle-LoadFromStream-Async" class="headerlink" title="AssetBundle.LoadFromStream(Async)"></a>AssetBundle.LoadFromStream(Async)</h3><p>与 LoadFromFile 类似， LZMA 格式压缩的会被解压进内存，未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会直接通过 Stream 来读取</p>
<h2 id="加载-Assets"><a href="#加载-Assets" class="headerlink" title="加载 Assets"></a>加载 Assets</h2><p>获得到 AssetBundle 对象后，即可通过 bundle 对象 load 相关 Asset。加载完成的 Asset 会进入内存中，实例化需要单独进行.<br><img src="/2020/06/18/AssetBundle简析/6.png" class="NO compression"></p>
<h1 id="AssetBundle-的卸载"><a href="#AssetBundle-的卸载" class="headerlink" title="AssetBundle 的卸载"></a>AssetBundle 的卸载</h1><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><img src="/2020/06/18/AssetBundle简析/5.jpg" class="NO compression">
<p>根据上图可详细的获取到，卸载各区域内存的方法。合理应用卸载和加载管理好游戏运行时的内存。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>压缩虽然能减少 AB 包体的大小，但是在运行时会分配内存保存解压后的 Bundle 内容。在实际项目中，需要合理的根据情况权衡打包的方案。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>BST(二叉搜索树)</title>
    <url>/2020/04/29/BST/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>树的数据结构觉得了它能构建成索引结构，且能高效的减少集合的搜索深度，再配合上有序的插入规则，就能进行高效的搜索。这里介绍一种简单的二叉搜索树（BST），BST 的插入规则为，任意节点的左孩子比自身小，右孩子比自身大。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>时间复杂度：O(log<sub>2</sub>N)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_insert</span><span class="params">(self, parent, node)</span>:</span></span><br><span class="line">    <span class="comment">## 这里不处理相同的数</span></span><br><span class="line">    <span class="keyword">if</span> parent.value == node.value:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">## 比较顺序后放入较小的左子树</span></span><br><span class="line">    <span class="keyword">elif</span> parent.value &gt; node.value:</span><br><span class="line">        <span class="comment">## 孩子为空，可以插入</span></span><br><span class="line">        <span class="keyword">if</span> parent.left == <span class="literal">None</span>:</span><br><span class="line">            parent.left = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._insert(parent.left, node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="comment">## 比较顺序后放入较大的右子树</span></span><br><span class="line">    <span class="keyword">elif</span> parent.value &lt; node.value:</span><br><span class="line">        <span class="comment">## 孩子为空，可以插入</span></span><br><span class="line">        <span class="keyword">if</span> parent.right == <span class="literal">None</span>:</span><br><span class="line">            parent.right = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._insert(parent.right, node)</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p>时间复杂度：O(log<sub>2</sub>N)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self,node, key, parent, isLeft)</span>:</span></span><br><span class="line">    <span class="comment">## 搜索节点</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">## 搜索较大的右子树</span></span><br><span class="line">    <span class="keyword">elif</span> node.value &lt; key:</span><br><span class="line">        <span class="keyword">return</span> self._remove(node.right, key, node, <span class="literal">False</span>)</span><br><span class="line">    <span class="comment">## 搜索较的左子树</span></span><br><span class="line">    <span class="keyword">elif</span> node.value &gt; key:</span><br><span class="line">        <span class="keyword">return</span> self._remove(node.left, key, node, <span class="literal">True</span>)</span><br><span class="line">    <span class="comment">## 执行移除</span></span><br><span class="line">    <span class="keyword">elif</span> node.value == key:</span><br><span class="line">        rmNode = node</span><br><span class="line">        <span class="comment">## 左右子树任意一个为空，都可以直接把另外一个子树提上一层，替换掉移除的节点</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span>:</span><br><span class="line">            parent.setChild(isLeft, node.right)</span><br><span class="line">        <span class="keyword">elif</span> parent.right == <span class="literal">None</span>:</span><br><span class="line">            parent.setChild(isLeft, node.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">## 左右子树不为空</span></span><br><span class="line">            last = node</span><br><span class="line">            <span class="comment">## 在较大的右子树中找到最小的节点与移除的节点进行替换，并移除目标节点</span></span><br><span class="line">            minNode = node.right</span><br><span class="line">            <span class="keyword">while</span> minNode.left:</span><br><span class="line">                last = minNode</span><br><span class="line">                minNode = minNode.left</span><br><span class="line">            </span><br><span class="line">            parent.setChild(isLeft, minNode)</span><br><span class="line">            last.setChild(<span class="literal">True</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rmNode</span><br></pre></td></tr></table></figure></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><blockquote>
<p>按照比较顺序进行搜索，可以快速确定目标元素所在子树，减少冗余枝干的遍历操作。</p>
</blockquote>
<p>时间复杂度：O(log<sub>2</sub>N)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_search</span><span class="params">(self, parent, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> parent.value == value:</span><br><span class="line">        <span class="keyword">return</span> parent,<span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> parent.value &lt; value:</span><br><span class="line">        <span class="keyword">return</span> self._search(parent.right, value)</span><br><span class="line">    <span class="keyword">elif</span> parent.value &gt; value:</span><br><span class="line">        <span class="keyword">return</span> self._search(parent.left, value)</span><br></pre></td></tr></table></figure></p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h2><p>BST 的所有操作都与树的深度有关，在插入操作时，如果插入的顺序是有序的，那么 BST 就会变成深度为 N 的一叉树，大大降低搜索效率。所以在初始化时，可以进行随机取数，减少有序的概率。</p>
<p>以下是此数据结构的 python 实现<br>github:[<a href="https://github.com/dupouyer/algo/tree/master/BST]" target="_blank" rel="noopener">https://github.com/dupouyer/algo/tree/master/BST]</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构</title>
    <url>/2020/04/07/BasicDataStructure/</url>
    <content><![CDATA[<blockquote>
<p>基本的数据结构类型</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>最常用的数据结构</p>
</blockquote>
<p>在内存中申请一块固定长度连续空间，可通过下标来访问<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array = malloc(n);</span><br></pre></td></tr></table></figure></p>
<p>因为内存需要提前申请，所以在使用上如果遇到可变长度的存储需求时，需要频繁申请新的内存块，会有严重的内存开销问题，所以引入了链表</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>以节点为存储单元，一个节点包含值与下一个节点的地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linkNode = malloc(2);</span><br><span class="line">linkNode[1] = value;</span><br><span class="line">linkeNode[2] = &amp;nextNode;</span><br></pre></td></tr></table></figure></p>
<p>可根据存储需求临时开辟存储空间。但是在访问单个节点上效率又没有数组来的快捷，需要从头节点逐个遍历至 i。<br>现代编程语言大多实现了 List 类型的数据结构综合两者的优缺点，实现了可变长度且可通过下标访问成员。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>通过内部算法，动态开辟符合长度的内存空间来满足长度需求，不同编程语言的实现方法也会不一样。<br>一下简述一下个人对于 List 一种实现方案  </p>
<blockquote>
<p>设置一个合适长度的子数组 (subArray) 长度 k , 根据 List 的长度动态创建以及销毁子数组。<br>设置一个链表 (nodes) 存储子数组的头节点。<br>内置长度计数器 count<br>访问 List[i] = nodes[i % k][int(i / k)]  </p>
</blockquote>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出，特点是优先处理最早加入的节点</p>
<blockquote>
<p>广度搜索中应用此结构辅助记录每次需要搜索的节点。</p>
</blockquote>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出，特点是优先处理最近加入的节点</p>
<blockquote>
<p>深度搜索中应用此结构辅助记录每次需要搜索的节点。</p>
</blockquote>
<p>队列和栈是两个老生常谈的结构，实现方法有多种。在这里就不详述了,需要的可以自行查找。</p>
<h2 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h2><p>给定一个 key 值，通过 hask 函数 adress = hash(key), 获得 key 对应的固定地址。如果有多个key 返回同样的hash值,通过冲突解决函数来获得偏移地址。 hash 表虽然在实现的描述上性能优越，可变长度，快速访问。但是在编程语言中的实现还是需要落在实处，需要基础的数组，链表来实现。</p>
<h2 id="脚本语言中的-Dictionary-类实现"><a href="#脚本语言中的-Dictionary-类实现" class="headerlink" title="脚本语言中的 Dictionary 类实现"></a>脚本语言中的 Dictionary 类实现</h2><p>这里举例一个字典的实现。<br>两个链表，一个 存储 hask 值 一个存储 value 的引用，从图中可以看出，虽然字典获得快速访问优势，但是付出了更多的空间代价。</p>
<blockquote>
<p>基本的数据结构类型</p>
</blockquote>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>最常用的数据结构</p>
</blockquote>
<p>在内存中申请一块固定长度连续空间，可通过下标来访问<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array = malloc(n);</span><br></pre></td></tr></table></figure></p>
<p>因为内存需要提前申请，所以在使用上如果遇到可变长度的存储需求时，需要频繁申请新的内存块，会有严重的内存开销问题，所以引入了链表</p>
<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><p>以节点为存储单元，一个节点包含值与下一个节点的地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linkNode = malloc(2);</span><br><span class="line">linkNode[1] = value;</span><br><span class="line">linkeNode[2] = &amp;nextNode;</span><br></pre></td></tr></table></figure></p>
<p>可根据存储需求临时开辟存储空间。但是在访问单个节点上效率又没有数组来的快捷，需要从头节点逐个遍历至 i。<br>现代编程语言大多实现了 List 类型的数据结构综合两者的优缺点，实现了可变长度且可通过下标访问成员。</p>
<h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h2><p>通过内部算法，动态开辟符合长度的内存空间来满足长度需求，不同编程语言的实现方法也会不一样。<br>一下简述一下个人对于 List 一种实现方案  </p>
<blockquote>
<p>设置一个合适长度的子数组 (subArray) 长度 k , 根据 List 的长度动态创建以及销毁子数组。<br>设置一个链表 (nodes) 存储子数组的头节点。<br>内置长度计数器 count<br>访问 List[i] = nodes[i % k][int(i / k)]  </p>
</blockquote>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><p>先进先出，特点是优先处理最早加入的节点</p>
<blockquote>
<p>广度搜索中应用此结构辅助记录每次需要搜索的节点。</p>
</blockquote>
<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><p>先进后出，特点是优先处理最近加入的节点</p>
<blockquote>
<p>深度搜索中应用此结构辅助记录每次需要搜索的节点。</p>
</blockquote>
<p>队列和栈是两个老生常谈的结构，实现方法有多种。在这里就不详述了,需要的可以自行查找。</p>
<h2 id="hash表-1"><a href="#hash表-1" class="headerlink" title="hash表"></a>hash表</h2><p>给定一个 key 值，通过 hask 函数 adress = hash(key), 获得 key 对应的固定地址。如果有多个key 返回同样的hash值,通过冲突解决函数来获得偏移地址。 hash 表虽然在实现的描述上性能优越，可变长度，快速访问。但是在编程语言中的实现还是需要落在实处，需要基础的数组，链表来实现。</p>
<h2 id="脚本语言中的-Dictionary-类实现-1"><a href="#脚本语言中的-Dictionary-类实现-1" class="headerlink" title="脚本语言中的 Dictionary 类实现"></a>脚本语言中的 Dictionary 类实现</h2><p>这里举例一个字典的实现。<br>两个链表，一个 存储 hask 值 一个存储 value 的引用，从图中可以看出，虽然字典获得快速访问优势，但是付出了更多的空间代价。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2381726-fb4e3aaa4b98af99.png?imageMogr2/auto-orient/strip|imageView2/2/w/450/format/webp" alt="avatar"></p>
<p>以上就是编程语言中常用的基础数据结构。后续高级的数据结构都无法脱离数组和链表这两种基础结构，都是以两者为存储单元，再配以存取逻辑来实现的。</p>
<p>以上就是编程语言中常用的基础数据结构。后续高级的数据结构都无法脱离数组和链表这两种基础结构，都是以两者为存储单元，再配以存取逻辑来实现的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Stripping with IL2CPP</title>
    <url>/2020/06/02/Stripping-with-IL2CPP/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>项目中为了减少打包后的包体大小，针对 IL2CPP 的打包方案做包体缩小的优化</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>IL2CPP 虽然在性能上比 mono 有优势，但是当代码量增多时，包体会增大</p>
<h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><p>2015 年的一篇帖子有提到 IL2CPP 在打包时会将未使用的属性打包进 IL 中，作者测评下来发现修改裁剪工具，剔除不需要的属性能减少 6% 的 IL2Cpp 大小。<br><a href="https://forum.unity.com/threads/suggestion-for-reducing-the-size-of-il2cpp-generated-executable.338986/" target="_blank" rel="noopener">原帖地址</a><br>在 unity2017 版本中，并没有作者所提到的 UnusedByteCodeStripper2.exe 工具，推测 unity 可能在后续版本更新中做了优化。</p>
<h3 id="测试-Attribute-的优化"><a href="#测试-Attribute-的优化" class="headerlink" title="测试 Attribute 的优化"></a>测试 Attribute 的优化</h3><p>新建空的项目工程，创建 test.cs , 对其中的 test 字段使用属性元数据。 选择 IL2Cpp 打包方案打包 apk 包，使用 <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">IL2Cppdumper</a> ，反编译查看包体中的 libil2cpp.so ， 对比查看使用了属性以及未使用属性的打包结果。</p>
<h1 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h1><p>项目中为了减少打包后的包体大小，针对 IL2CPP 的打包方案做包体缩小的优化</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>IL2CPP 虽然在性能上比 mono 有优势，但是当代码量增多时，包体会增大</p>
<h2 id="研究-1"><a href="#研究-1" class="headerlink" title="研究"></a>研究</h2><p>2015 年的一篇帖子有提到 IL2CPP 在打包时会将未使用的属性打包进 IL 中，作者测评下来发现修改裁剪工具，剔除不需要的属性能减少 6% 的 IL2Cpp 大小。<br><a href="https://forum.unity.com/threads/suggestion-for-reducing-the-size-of-il2cpp-generated-executable.338986/" target="_blank" rel="noopener">原帖地址</a><br>在 unity2017 版本中，并没有作者所提到的 UnusedByteCodeStripper2.exe 工具，推测 unity 可能在后续版本更新中做了优化。</p>
<h3 id="测试-Attribute-的优化-1"><a href="#测试-Attribute-的优化-1" class="headerlink" title="测试 Attribute 的优化"></a>测试 Attribute 的优化</h3><p>新建空的项目工程，创建 test.cs , 对其中的 test 字段使用属性元数据。 选择 IL2Cpp 打包方案打包 apk 包，使用 <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">IL2Cppdumper</a> ，反编译查看包体中的 libil2cpp.so ， 对比查看使用了属性以及未使用属性的打包结果。</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/1.png" alt="使用属性"></p>
<p>未使用属性的 attribute 在反编译结果中未找到对应的声明<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/2.png" alt="反编译结果"></p>
<h3 id="Managed-bytecode-stripping-with-IL2CPP"><a href="#Managed-bytecode-stripping-with-IL2CPP" class="headerlink" title="Managed bytecode stripping with IL2CPP"></a>Managed bytecode stripping with IL2CPP</h3><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/3.png" alt="Strip Engine Code"><br>查找文档发现 unity2017 已经新增了对 IL 代码的裁剪选项，此选项开启后会使用 UnityLinker(is a version of the <a href="https://github.com/mono/linker" target="_blank" rel="noopener">Mono IL Linker</a>) 对引擎中未引用的代码进行剔除。<br>剔除工作是基于代码的静态分析，需要注意以下情况，并处理。</p>
<ul>
<li>如果代码中使用了反射来引用，可能会出现运行时引用类型被剔除的报错。</li>
<li>项目打包中会有 prefab 资源的提前构建 ab 包，此构建过程在 UnityLinker 调用之前执行，一些类型的引用只存在与 Prefab 中，也会出现类型丢失问题。需要手动排查并引用进 mono 防止类型被剔除。</li>
</ul>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>对裁剪后的包进行冒烟测试，查找并修复类型丢失的问题。</p>
<blockquote>
<p>运行时，unity 会抛出类型丢失的错误，并附带一个应用 ID， 通过 <a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">ClassIDRefrence</a>  查找，获知对应的类型。</p>
</blockquote>
<h3 id="反射引用"><a href="#反射引用" class="headerlink" title="反射引用"></a>反射引用</h3><p>测试下来并未出现有相关类型报错的问题，说明代码中没有通过这种方法对类型进行引用。</p>
<h3 id="资源-ab-包"><a href="#资源-ab-包" class="headerlink" title="资源 ab 包"></a>资源 ab 包</h3><p>出现一些 Prefab 引用类型丢失的情况，新增 link.xml 放置在 Assets 下，指导 UnityLinker 的剔除保留。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"System"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"System.ComponentModel.TypeConverter"</span> <span class="attr">preserve</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"mscorlib"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span> <span class="attr">fullname</span>=<span class="string">"System.Security.Cryptography"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Flare"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Avatar"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>最终包体缩小 34MB</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/4.png" alt="结果1"><br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/5.png" alt="结果2"></p>
<p>未使用属性的 attribute 在反编译结果中未找到对应的声明</p>
<h1 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h1><p>项目中为了减少打包后的包体大小，针对 IL2CPP 的打包方案做包体缩小的优化</p>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>IL2CPP 虽然在性能上比 mono 有优势，但是当代码量增多时，包体会增大</p>
<h2 id="研究-2"><a href="#研究-2" class="headerlink" title="研究"></a>研究</h2><p>2015 年的一篇帖子有提到 IL2CPP 在打包时会将未使用的属性打包进 IL 中，作者测评下来发现修改裁剪工具，剔除不需要的属性能减少 6% 的 IL2Cpp 大小。<br><a href="https://forum.unity.com/threads/suggestion-for-reducing-the-size-of-il2cpp-generated-executable.338986/" target="_blank" rel="noopener">原帖地址</a><br>在 unity2017 版本中，并没有作者所提到的 UnusedByteCodeStripper2.exe 工具，推测 unity 可能在后续版本更新中做了优化。</p>
<h3 id="测试-Attribute-的优化-2"><a href="#测试-Attribute-的优化-2" class="headerlink" title="测试 Attribute 的优化"></a>测试 Attribute 的优化</h3><p>新建空的项目工程，创建 test.cs , 对其中的 test 字段使用属性元数据。 选择 IL2Cpp 打包方案打包 apk 包，使用 <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">IL2Cppdumper</a> ，反编译查看包体中的 libil2cpp.so ， 对比查看使用了属性以及未使用属性的打包结果。</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/1.png" alt="使用属性"></p>
<p>未使用属性的 attribute 在反编译结果中未找到对应的声明<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/2.png" alt="反编译结果"></p>
<h3 id="Managed-bytecode-stripping-with-IL2CPP-1"><a href="#Managed-bytecode-stripping-with-IL2CPP-1" class="headerlink" title="Managed bytecode stripping with IL2CPP"></a>Managed bytecode stripping with IL2CPP</h3><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/3.png" alt="Strip Engine Code"><br>查找文档发现 unity2017 已经新增了对 IL 代码的裁剪选项，此选项开启后会使用 UnityLinker(is a version of the <a href="https://github.com/mono/linker" target="_blank" rel="noopener">Mono IL Linker</a>) 对引擎中未引用的代码进行剔除。<br>剔除工作是基于代码的静态分析，需要注意以下情况，并处理。</p>
<ul>
<li>如果代码中使用了反射来引用，可能会出现运行时引用类型被剔除的报错。</li>
<li>项目打包中会有 prefab 资源的提前构建 ab 包，此构建过程在 UnityLinker 调用之前执行，一些类型的引用只存在与 Prefab 中，也会出现类型丢失问题。需要手动排查并引用进 mono 防止类型被剔除。</li>
</ul>
<h2 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h2><p>对裁剪后的包进行冒烟测试，查找并修复类型丢失的问题。</p>
<blockquote>
<p>运行时，unity 会抛出类型丢失的错误，并附带一个应用 ID， 通过 <a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">ClassIDRefrence</a>  查找，获知对应的类型。</p>
</blockquote>
<h3 id="反射引用-1"><a href="#反射引用-1" class="headerlink" title="反射引用"></a>反射引用</h3><p>测试下来并未出现有相关类型报错的问题，说明代码中没有通过这种方法对类型进行引用。</p>
<h3 id="资源-ab-包-1"><a href="#资源-ab-包-1" class="headerlink" title="资源 ab 包"></a>资源 ab 包</h3><p>出现一些 Prefab 引用类型丢失的情况，新增 link.xml 放置在 Assets 下，指导 UnityLinker 的剔除保留。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"System"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"System.ComponentModel.TypeConverter"</span> <span class="attr">preserve</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"mscorlib"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span> <span class="attr">fullname</span>=<span class="string">"System.Security.Cryptography"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Flare"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Avatar"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p>最终包体缩小 34MB</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/4.png" alt="结果1"><br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/5.png" alt="结果2"></p>
<h3 id="Managed-bytecode-stripping-with-IL2CPP-2"><a href="#Managed-bytecode-stripping-with-IL2CPP-2" class="headerlink" title="Managed bytecode stripping with IL2CPP"></a>Managed bytecode stripping with IL2CPP</h3><h1 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h1><p>项目中为了减少打包后的包体大小，针对 IL2CPP 的打包方案做包体缩小的优化</p>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><p>IL2CPP 虽然在性能上比 mono 有优势，但是当代码量增多时，包体会增大</p>
<h2 id="研究-3"><a href="#研究-3" class="headerlink" title="研究"></a>研究</h2><p>2015 年的一篇帖子有提到 IL2CPP 在打包时会将未使用的属性打包进 IL 中，作者测评下来发现修改裁剪工具，剔除不需要的属性能减少 6% 的 IL2Cpp 大小。<br><a href="https://forum.unity.com/threads/suggestion-for-reducing-the-size-of-il2cpp-generated-executable.338986/" target="_blank" rel="noopener">原帖地址</a><br>在 unity2017 版本中，并没有作者所提到的 UnusedByteCodeStripper2.exe 工具，推测 unity 可能在后续版本更新中做了优化。</p>
<h3 id="测试-Attribute-的优化-3"><a href="#测试-Attribute-的优化-3" class="headerlink" title="测试 Attribute 的优化"></a>测试 Attribute 的优化</h3><p>新建空的项目工程，创建 test.cs , 对其中的 test 字段使用属性元数据。 选择 IL2Cpp 打包方案打包 apk 包，使用 <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">IL2Cppdumper</a> ，反编译查看包体中的 libil2cpp.so ， 对比查看使用了属性以及未使用属性的打包结果。</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/1.png" alt="使用属性"></p>
<p>未使用属性的 attribute 在反编译结果中未找到对应的声明<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/2.png" alt="反编译结果"></p>
<h3 id="Managed-bytecode-stripping-with-IL2CPP-3"><a href="#Managed-bytecode-stripping-with-IL2CPP-3" class="headerlink" title="Managed bytecode stripping with IL2CPP"></a>Managed bytecode stripping with IL2CPP</h3><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/3.png" alt="Strip Engine Code"><br>查找文档发现 unity2017 已经新增了对 IL 代码的裁剪选项，此选项开启后会使用 UnityLinker(is a version of the <a href="https://github.com/mono/linker" target="_blank" rel="noopener">Mono IL Linker</a>) 对引擎中未引用的代码进行剔除。<br>剔除工作是基于代码的静态分析，需要注意以下情况，并处理。</p>
<ul>
<li>如果代码中使用了反射来引用，可能会出现运行时引用类型被剔除的报错。</li>
<li>项目打包中会有 prefab 资源的提前构建 ab 包，此构建过程在 UnityLinker 调用之前执行，一些类型的引用只存在与 Prefab 中，也会出现类型丢失问题。需要手动排查并引用进 mono 防止类型被剔除。</li>
</ul>
<h2 id="执行-2"><a href="#执行-2" class="headerlink" title="执行"></a>执行</h2><p>对裁剪后的包进行冒烟测试，查找并修复类型丢失的问题。</p>
<blockquote>
<p>运行时，unity 会抛出类型丢失的错误，并附带一个应用 ID， 通过 <a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">ClassIDRefrence</a>  查找，获知对应的类型。</p>
</blockquote>
<h3 id="反射引用-2"><a href="#反射引用-2" class="headerlink" title="反射引用"></a>反射引用</h3><p>测试下来并未出现有相关类型报错的问题，说明代码中没有通过这种方法对类型进行引用。</p>
<h3 id="资源-ab-包-2"><a href="#资源-ab-包-2" class="headerlink" title="资源 ab 包"></a>资源 ab 包</h3><p>出现一些 Prefab 引用类型丢失的情况，新增 link.xml 放置在 Assets 下，指导 UnityLinker 的剔除保留。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"System"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"System.ComponentModel.TypeConverter"</span> <span class="attr">preserve</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"mscorlib"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span> <span class="attr">fullname</span>=<span class="string">"System.Security.Cryptography"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Flare"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Avatar"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><p>最终包体缩小 34MB</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/4.png" alt="结果1"><br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/5.png" alt="结果2"><br>查找文档发现 unity2017 已经新增了对 IL 代码的裁剪选项，此选项开启后会使用 UnityLinker(is a version of the <a href="https://github.com/mono/linker" target="_blank" rel="noopener">Mono IL Linker</a>) 对引擎中未引用的代码进行剔除。<br>剔除工作是基于代码的静态分析，需要注意以下情况，并处理。</p>
<ul>
<li>如果代码中使用了反射来引用，可能会出现运行时引用类型被剔除的报错。</li>
<li>项目打包中会有 prefab 资源的提前构建 ab 包，此构建过程在 UnityLinker 调用之前执行，一些类型的引用只存在与 Prefab 中，也会出现类型丢失问题。需要手动排查并引用进 mono 防止类型被剔除。</li>
</ul>
<h2 id="执行-3"><a href="#执行-3" class="headerlink" title="执行"></a>执行</h2><p>对裁剪后的包进行冒烟测试，查找并修复类型丢失的问题。</p>
<blockquote>
<p>运行时，unity 会抛出类型丢失的错误，并附带一个应用 ID， 通过 <a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">ClassIDRefrence</a>  查找，获知对应的类型。</p>
</blockquote>
<h3 id="反射引用-3"><a href="#反射引用-3" class="headerlink" title="反射引用"></a>反射引用</h3><p>测试下来并未出现有相关类型报错的问题，说明代码中没有通过这种方法对类型进行引用。</p>
<h3 id="资源-ab-包-3"><a href="#资源-ab-包-3" class="headerlink" title="资源 ab 包"></a>资源 ab 包</h3><p>出现一些 Prefab 引用类型丢失的情况，新增 link.xml 放置在 Assets 下，指导 UnityLinker 的剔除保留。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"System"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"System.ComponentModel.TypeConverter"</span> <span class="attr">preserve</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"mscorlib"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span> <span class="attr">fullname</span>=<span class="string">"System.Security.Cryptography"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Flare"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Avatar"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h2><p>最终包体缩小 34MB</p>
<h1 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h1><p>项目中为了减少打包后的包体大小，针对 IL2CPP 的打包方案做包体缩小的优化</p>
<h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h2><p>IL2CPP 虽然在性能上比 mono 有优势，但是当代码量增多时，包体会增大</p>
<h2 id="研究-4"><a href="#研究-4" class="headerlink" title="研究"></a>研究</h2><p>2015 年的一篇帖子有提到 IL2CPP 在打包时会将未使用的属性打包进 IL 中，作者测评下来发现修改裁剪工具，剔除不需要的属性能减少 6% 的 IL2Cpp 大小。<br><a href="https://forum.unity.com/threads/suggestion-for-reducing-the-size-of-il2cpp-generated-executable.338986/" target="_blank" rel="noopener">原帖地址</a><br>在 unity2017 版本中，并没有作者所提到的 UnusedByteCodeStripper2.exe 工具，推测 unity 可能在后续版本更新中做了优化。</p>
<h3 id="测试-Attribute-的优化-4"><a href="#测试-Attribute-的优化-4" class="headerlink" title="测试 Attribute 的优化"></a>测试 Attribute 的优化</h3><p>新建空的项目工程，创建 test.cs , 对其中的 test 字段使用属性元数据。 选择 IL2Cpp 打包方案打包 apk 包，使用 <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">IL2Cppdumper</a> ，反编译查看包体中的 libil2cpp.so ， 对比查看使用了属性以及未使用属性的打包结果。</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/1.png" alt="使用属性"></p>
<p>未使用属性的 attribute 在反编译结果中未找到对应的声明<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/2.png" alt="反编译结果"></p>
<h3 id="Managed-bytecode-stripping-with-IL2CPP-4"><a href="#Managed-bytecode-stripping-with-IL2CPP-4" class="headerlink" title="Managed bytecode stripping with IL2CPP"></a>Managed bytecode stripping with IL2CPP</h3><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/3.png" alt="Strip Engine Code"><br>查找文档发现 unity2017 已经新增了对 IL 代码的裁剪选项，此选项开启后会使用 UnityLinker(is a version of the <a href="https://github.com/mono/linker" target="_blank" rel="noopener">Mono IL Linker</a>) 对引擎中未引用的代码进行剔除。<br>剔除工作是基于代码的静态分析，需要注意以下情况，并处理。</p>
<ul>
<li>如果代码中使用了反射来引用，可能会出现运行时引用类型被剔除的报错。</li>
<li>项目打包中会有 prefab 资源的提前构建 ab 包，此构建过程在 UnityLinker 调用之前执行，一些类型的引用只存在与 Prefab 中，也会出现类型丢失问题。需要手动排查并引用进 mono 防止类型被剔除。</li>
</ul>
<h2 id="执行-4"><a href="#执行-4" class="headerlink" title="执行"></a>执行</h2><p>对裁剪后的包进行冒烟测试，查找并修复类型丢失的问题。</p>
<blockquote>
<p>运行时，unity 会抛出类型丢失的错误，并附带一个应用 ID， 通过 <a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">ClassIDRefrence</a>  查找，获知对应的类型。</p>
</blockquote>
<h3 id="反射引用-4"><a href="#反射引用-4" class="headerlink" title="反射引用"></a>反射引用</h3><p>测试下来并未出现有相关类型报错的问题，说明代码中没有通过这种方法对类型进行引用。</p>
<h3 id="资源-ab-包-4"><a href="#资源-ab-包-4" class="headerlink" title="资源 ab 包"></a>资源 ab 包</h3><p>出现一些 Prefab 引用类型丢失的情况，新增 link.xml 放置在 Assets 下，指导 UnityLinker 的剔除保留。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"System"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"System.ComponentModel.TypeConverter"</span> <span class="attr">preserve</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"mscorlib"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span> <span class="attr">fullname</span>=<span class="string">"System.Security.Cryptography"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Flare"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Avatar"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h2><p>最终包体缩小 34MB</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/4.png" alt="结果1"><br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/5.png" alt="结果2"></p>
<h1 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h1><p>项目中为了减少打包后的包体大小，针对 IL2CPP 的打包方案做包体缩小的优化</p>
<h2 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h2><p>IL2CPP 虽然在性能上比 mono 有优势，但是当代码量增多时，包体会增大</p>
<h2 id="研究-5"><a href="#研究-5" class="headerlink" title="研究"></a>研究</h2><p>2015 年的一篇帖子有提到 IL2CPP 在打包时会将未使用的属性打包进 IL 中，作者测评下来发现修改裁剪工具，剔除不需要的属性能减少 6% 的 IL2Cpp 大小。<br><a href="https://forum.unity.com/threads/suggestion-for-reducing-the-size-of-il2cpp-generated-executable.338986/" target="_blank" rel="noopener">原帖地址</a><br>在 unity2017 版本中，并没有作者所提到的 UnusedByteCodeStripper2.exe 工具，推测 unity 可能在后续版本更新中做了优化。</p>
<h3 id="测试-Attribute-的优化-5"><a href="#测试-Attribute-的优化-5" class="headerlink" title="测试 Attribute 的优化"></a>测试 Attribute 的优化</h3><p>新建空的项目工程，创建 test.cs , 对其中的 test 字段使用属性元数据。 选择 IL2Cpp 打包方案打包 apk 包，使用 <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">IL2Cppdumper</a> ，反编译查看包体中的 libil2cpp.so ， 对比查看使用了属性以及未使用属性的打包结果。</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/1.png" alt="使用属性"></p>
<p>未使用属性的 attribute 在反编译结果中未找到对应的声明<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/2.png" alt="反编译结果"></p>
<h3 id="Managed-bytecode-stripping-with-IL2CPP-5"><a href="#Managed-bytecode-stripping-with-IL2CPP-5" class="headerlink" title="Managed bytecode stripping with IL2CPP"></a>Managed bytecode stripping with IL2CPP</h3><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/3.png" alt="Strip Engine Code"><br>查找文档发现 unity2017 已经新增了对 IL 代码的裁剪选项，此选项开启后会使用 UnityLinker(is a version of the <a href="https://github.com/mono/linker" target="_blank" rel="noopener">Mono IL Linker</a>) 对引擎中未引用的代码进行剔除。<br>剔除工作是基于代码的静态分析，需要注意以下情况，并处理。</p>
<ul>
<li>如果代码中使用了反射来引用，可能会出现运行时引用类型被剔除的报错。</li>
<li>项目打包中会有 prefab 资源的提前构建 ab 包，此构建过程在 UnityLinker 调用之前执行，一些类型的引用只存在与 Prefab 中，也会出现类型丢失问题。需要手动排查并引用进 mono 防止类型被剔除。</li>
</ul>
<h2 id="执行-5"><a href="#执行-5" class="headerlink" title="执行"></a>执行</h2><p>对裁剪后的包进行冒烟测试，查找并修复类型丢失的问题。</p>
<blockquote>
<p>运行时，unity 会抛出类型丢失的错误，并附带一个应用 ID， 通过 <a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">ClassIDRefrence</a>  查找，获知对应的类型。</p>
</blockquote>
<h3 id="反射引用-5"><a href="#反射引用-5" class="headerlink" title="反射引用"></a>反射引用</h3><p>测试下来并未出现有相关类型报错的问题，说明代码中没有通过这种方法对类型进行引用。</p>
<h3 id="资源-ab-包-5"><a href="#资源-ab-包-5" class="headerlink" title="资源 ab 包"></a>资源 ab 包</h3><p>出现一些 Prefab 引用类型丢失的情况，新增 link.xml 放置在 Assets 下，指导 UnityLinker 的剔除保留。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"System"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"System.ComponentModel.TypeConverter"</span> <span class="attr">preserve</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"mscorlib"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span> <span class="attr">fullname</span>=<span class="string">"System.Security.Cryptography"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Flare"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Avatar"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h2><p>最终包体缩小 34MB</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/4.png" alt="结果1"><br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_6_2/5.png" alt="结果2"></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>UPR使用</title>
    <url>/2020/06/04/UPR%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。  </li>
</ul>
<h1 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-1"><a href="#项目准备-1" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备"><a href="#测试包准备" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台"><a href="#anroid-平台" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台"><a href="#windows-平台" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>按要求填写相关项目信息。</p>
<ul>
<li>进入新建好的项目，点击新建测试</li>
</ul>
<h1 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-2"><a href="#项目准备-2" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备-1"><a href="#测试包准备-1" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-1"><a href="#anroid-平台-1" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-1"><a href="#windows-平台-1" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析-1"><a href="#数据分析-1" class="headerlink" title="数据分析"></a>数据分析</h1><p>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。  </p>
<h1 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-3"><a href="#项目准备-3" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备-2"><a href="#测试包准备-2" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-2"><a href="#anroid-平台-2" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-2"><a href="#windows-平台-2" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析-2"><a href="#数据分析-2" class="headerlink" title="数据分析"></a>数据分析</h1><p>创建完成  </p>
<h2 id="测试包准备-3"><a href="#测试包准备-3" class="headerlink" title="测试包准备"></a>测试包准备</h2><p>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</p>
<ul>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-3"><a href="#anroid-平台-3" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试  </li>
</ul>
<h1 id="环境准备-4"><a href="#环境准备-4" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-4"><a href="#项目准备-4" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备-4"><a href="#测试包准备-4" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-4"><a href="#anroid-平台-4" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-3"><a href="#windows-平台-3" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析-3"><a href="#数据分析-3" class="headerlink" title="数据分析"></a>数据分析</h1><ul>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-4"><a href="#windows-平台-4" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动</p>
<h1 id="环境准备-5"><a href="#环境准备-5" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-5"><a href="#项目准备-5" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备-5"><a href="#测试包准备-5" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-5"><a href="#anroid-平台-5" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-5"><a href="#windows-平台-5" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析-4"><a href="#数据分析-4" class="headerlink" title="数据分析"></a>数据分析</h1><ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test  </li>
</ul>
<h1 id="环境准备-6"><a href="#环境准备-6" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-6"><a href="#项目准备-6" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备-6"><a href="#测试包准备-6" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-6"><a href="#anroid-平台-6" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-6"><a href="#windows-平台-6" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析-5"><a href="#数据分析-5" class="headerlink" title="数据分析"></a>数据分析</h1><ul>
<li>点击 Stop and ProcessData 结束测试  </li>
</ul>
<h1 id="环境准备-7"><a href="#环境准备-7" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-7"><a href="#项目准备-7" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备-7"><a href="#测试包准备-7" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-7"><a href="#anroid-平台-7" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-7"><a href="#windows-平台-7" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析-6"><a href="#数据分析-6" class="headerlink" title="数据分析"></a>数据分析</h1><ul>
<li>前往网页项目，查看测试报告  </li>
</ul>
<h1 id="环境准备-8"><a href="#环境准备-8" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="项目准备-8"><a href="#项目准备-8" class="headerlink" title="项目准备"></a>项目准备</h2><ul>
<li>登入 <a href="https://upr.unity.com/" target="_blank" rel="noopener">Unity UPR 官网</a>, 登入账号，选择我的项目，点击创建项目。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/1.png" alt="新建项目"><br>按要求填写相关项目信息。</li>
<li>进入新建好的项目，点击新建测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/2.png" alt="新建测试"><br>根据测试需求开启相关测试选项。<br>PS: 项目包名需要与目标测试包保持一致。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/3.png" alt="创建完成"><br>创建完成  <h2 id="测试包准备-8"><a href="#测试包准备-8" class="headerlink" title="测试包准备"></a>测试包准备</h2>如果需要测试查看 Mono 和 Lua 的，则需要导入 UPRTools_V0.6.2.unitypackage。<br>不查看这两项数据的可以跳过此步骤。</li>
<li>导入 unitypackage</li>
<li>设置 UPRTools</li>
<li>发布</li>
</ul>
<h2 id="anroid-平台-8"><a href="#anroid-平台-8" class="headerlink" title="anroid 平台"></a>anroid 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR 安卓版并安装<br>根据提示，UPR 需要开启悬浮窗口权限，设置为开启。  </p>
<ul>
<li>启动 UPR<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/4.png" width="300" height="500" alt="启动UPR" align="center"></li>
<li>扫描网页上的测试二维码开启测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/5.png" alt="轮盘"></li>
<li>左上角会出现轮盘操作菜单，顺时针从左到右分别是开启测试，添加 Tag , 创建对象快照</li>
<li>停止测试后网页项目会同时停止</li>
<li>测试完成。</li>
</ul>
<h2 id="windows-平台-8"><a href="#windows-平台-8" class="headerlink" title="windows 平台"></a>windows 平台</h2><p>在 <a href="https://upr.unity.com/download" target="_blank" rel="noopener">官网</a> 下载最新的 UPR PC版本并安装启动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/6.png" alt="启动"></p>
<ul>
<li>拷贝测试项的 Session ID 填入，并 Load.</li>
<li>选择测试手机，可通过 IP 连接，也可通过 ABD（建议使用 ADB ）</li>
<li>点击 Start Test<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/7.png" alt="开启"></li>
<li>点击 Stop and ProcessData 结束测试<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/8.png" alt="结束"></li>
<li>前往网页项目，查看测试报告<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-4/9.png" alt="查看"></li>
</ul>
<h1 id="数据分析-7"><a href="#数据分析-7" class="headerlink" title="数据分析"></a>数据分析</h1><h1 id="数据分析-8"><a href="#数据分析-8" class="headerlink" title="数据分析"></a>数据分析</h1>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>UWA使用</title>
    <url>/2020/06/03/UWA%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容"><a href="#准备内容" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包</p>
<h1 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-1"><a href="#准备内容-1" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备"><a href="#Unity-工程准备" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备"><a href="#目标测试平台准备" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体"><a href="#发布目标平台包体" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online"><a href="#上传-online" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器"><a href="#上传本地服务器" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1"><a href="#用例1" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况"><a href="#CPU情况" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况"><a href="#GPU情况" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况"><a href="#内存情况" class="headerlink" title="内存情况"></a>内存情况</h3><h2 id="准备步骤-1"><a href="#准备步骤-1" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-1"><a href="#Unity-工程准备-1" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。</li>
</ul>
<h1 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-2"><a href="#准备内容-2" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-2"><a href="#准备步骤-2" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-2"><a href="#Unity-工程准备-2" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-1"><a href="#目标测试平台准备-1" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-1"><a href="#发布目标平台包体-1" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-1"><a href="#测试步骤-1" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-1"><a href="#上传-online-1" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-1"><a href="#上传本地服务器-1" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-1"><a href="#数据分析-1" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-1"><a href="#用例1-1" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-1"><a href="#CPU情况-1" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-1"><a href="#GPU情况-1" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-1"><a href="#内存情况-1" class="headerlink" title="内存情况"></a>内存情况</h3><ul>
<li>拖入 sdk 内的 prefab 至 scenes 下</li>
</ul>
<h1 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-3"><a href="#准备内容-3" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-3"><a href="#准备步骤-3" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-3"><a href="#Unity-工程准备-3" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-2"><a href="#目标测试平台准备-2" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-2"><a href="#发布目标平台包体-2" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-2"><a href="#测试步骤-2" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-2"><a href="#上传-online-2" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-2"><a href="#上传本地服务器-2" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-2"><a href="#数据分析-2" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-2"><a href="#用例1-2" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-2"><a href="#CPU情况-2" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-2"><a href="#GPU情况-2" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-2"><a href="#内存情况-2" class="headerlink" title="内存情况"></a>内存情况</h3><p>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。</p>
<h1 id="环境准备-4"><a href="#环境准备-4" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-4"><a href="#准备内容-4" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-4"><a href="#准备步骤-4" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-4"><a href="#Unity-工程准备-4" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-3"><a href="#目标测试平台准备-3" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-3"><a href="#发布目标平台包体-3" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-3"><a href="#测试步骤-3" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-3"><a href="#上传-online-3" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-3"><a href="#上传本地服务器-3" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-3"><a href="#数据分析-3" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-3"><a href="#用例1-3" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-3"><a href="#基本情况-3" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-3"><a href="#CPU情况-3" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-3"><a href="#GPU情况-3" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-3"><a href="#内存情况-3" class="headerlink" title="内存情况"></a>内存情况</h3><ul>
<li>点开 tools/UWASDK 进行 SDK 的配置</li>
</ul>
<h1 id="环境准备-5"><a href="#环境准备-5" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-5"><a href="#准备内容-5" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-5"><a href="#准备步骤-5" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-5"><a href="#Unity-工程准备-5" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-4"><a href="#目标测试平台准备-4" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-4"><a href="#发布目标平台包体-4" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-4"><a href="#测试步骤-4" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-4"><a href="#上传-online-4" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-4"><a href="#上传本地服务器-4" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-4"><a href="#数据分析-4" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-4"><a href="#用例1-4" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-4"><a href="#基本情况-4" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-4"><a href="#CPU情况-4" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-4"><a href="#GPU情况-4" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-4"><a href="#内存情况-4" class="headerlink" title="内存情况"></a>内存情况</h3><p>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<pre><code>- GOT 模式  
支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式
- GPM 模式  
只支持 Development Build 打包方式。支持四种测试模式，包含：

    | 模式 | android | ios | windows |
    | :----- | :----: | :----: | :----: |
    |Overview（总体性能分析）| √ | √ | √ |
    |Mono（Mono 堆内存分析）| √ | × | √ |
    |Assets（运行时资源）| √ |√ | √ |
    |Lua（Lua 性能分析）| √ |× | √ |
注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持  
Lua 模块仅适用于使用 Lua 的项目
</code></pre><h3 id="目标测试平台准备-5"><a href="#目标测试平台准备-5" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-5"><a href="#发布目标平台包体-5" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-5"><a href="#测试步骤-5" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li>启动游戏后，在右上角的 UWA 窗口选择测试模式。</li>
</ul>
<h1 id="环境准备-6"><a href="#环境准备-6" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-6"><a href="#准备内容-6" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-6"><a href="#准备步骤-6" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-6"><a href="#Unity-工程准备-6" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-6"><a href="#目标测试平台准备-6" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-6"><a href="#发布目标平台包体-6" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-6"><a href="#测试步骤-6" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-5"><a href="#上传-online-5" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-5"><a href="#上传本地服务器-5" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-5"><a href="#数据分析-5" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-5"><a href="#用例1-5" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-5"><a href="#基本情况-5" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-5"><a href="#CPU情况-5" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-5"><a href="#GPU情况-5" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-5"><a href="#内存情况-5" class="headerlink" title="内存情况"></a>内存情况</h3><p>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
<ul>
<li>点击 start 开启采集, 此 UI 可随意拖动  </li>
</ul>
<h1 id="环境准备-7"><a href="#环境准备-7" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-7"><a href="#准备内容-7" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-7"><a href="#准备步骤-7" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-7"><a href="#Unity-工程准备-7" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-7"><a href="#目标测试平台准备-7" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-7"><a href="#发布目标平台包体-7" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-7"><a href="#测试步骤-7" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-6"><a href="#上传-online-6" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-6"><a href="#上传本地服务器-6" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-6"><a href="#数据分析-6" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-6"><a href="#用例1-6" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-6"><a href="#基本情况-6" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-6"><a href="#CPU情况-6" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-6"><a href="#GPU情况-6" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-6"><a href="#内存情况-6" class="headerlink" title="内存情况"></a>内存情况</h3><ul>
<li>点击 stop 停止采集  </li>
</ul>
<h1 id="环境准备-8"><a href="#环境准备-8" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-8"><a href="#准备内容-8" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-8"><a href="#准备步骤-8" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-8"><a href="#Unity-工程准备-8" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-8"><a href="#目标测试平台准备-8" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-8"><a href="#发布目标平台包体-8" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-8"><a href="#测试步骤-8" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-7"><a href="#上传-online-7" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-7"><a href="#上传本地服务器-7" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-7"><a href="#数据分析-7" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-7"><a href="#用例1-7" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-7"><a href="#基本情况-7" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-7"><a href="#CPU情况-7" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-7"><a href="#GPU情况-7" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-7"><a href="#内存情况-7" class="headerlink" title="内存情况"></a>内存情况</h3><ul>
<li>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</li>
</ul>
<h3 id="上传-online-8"><a href="#上传-online-8" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-8"><a href="#上传本地服务器-8" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置</p>
<h1 id="环境准备-9"><a href="#环境准备-9" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="准备内容-9"><a href="#准备内容-9" class="headerlink" title="准备内容"></a>准备内容</h2><p>下载最新的 UWA_SDK,包含了三个平台的 unitypackage 以及目标真机平台和 windows 的UWATools安装包<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/1.png" alt="SDK内容"></p>
<h2 id="准备步骤-9"><a href="#准备步骤-9" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>这里以安卓平台为例</p>
<h3 id="Unity-工程准备-9"><a href="#Unity-工程准备-9" class="headerlink" title="Unity 工程准备"></a>Unity 工程准备</h3><ul>
<li>导入目标平台的 unitypackage ( UWA_SDKV2.2.0_Android.unitypackage ) 到需要测试的 unity 工程内。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/6.png" alt="导入SDK"></li>
<li>拖入 sdk 内的 prefab 至 scenes 下<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/5.png" alt="setPrefab"><br>Game窗口下出现 UWA 的插件 UI 并无报错信息，表示 SDK 接入成功。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/7.png" alt="SDK Completed"></li>
<li><p>点开 tools/UWASDK 进行 SDK 的配置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/2.png" alt="SDK Completed"><br>按照警告的提示进行编译设置或者选择自动配置，GOT 和 GPM 的选项表示 SDK 能以那种测试模式进行测试</p>
<ul>
<li>GOT 模式<br>支持 Android，iOS 和 Windows 发布平台，支持 Development Build 和 Release 打包方式</li>
<li><p>GPM 模式<br>只支持 Development Build 打包方式。支持四种测试模式，包含：</p>
<p>  | 模式 | android | ios | windows |<br>  | :—– | :—-: | :—-: | :—-: |<br>  |Overview（总体性能分析）| √ | √ | √ |<br>  |Mono（Mono 堆内存分析）| √ | × | √ |<br>  |Assets（运行时资源）| √ |√ | √ |<br>  |Lua（Lua 性能分析）| √ |× | √ |<br>注：若使用 il2cpp 发布设置时，各发布平台的 Mono 模式均不支持<br>Lua 模块仅适用于使用 Lua 的项目</p>
</li>
</ul>
</li>
</ul>
<h3 id="目标测试平台准备-9"><a href="#目标测试平台准备-9" class="headerlink" title="目标测试平台准备"></a>目标测试平台准备</h3><ul>
<li>安装 UWA_tools 并登入账号</li>
</ul>
<h3 id="发布目标平台包体-9"><a href="#发布目标平台包体-9" class="headerlink" title="发布目标平台包体"></a>发布目标平台包体</h3><ul>
<li>可以使用 SDK 的发布设置也可以用 buildplay 进行发布</li>
<li>安装此测试包至测试平台</li>
</ul>
<h2 id="测试步骤-9"><a href="#测试步骤-9" class="headerlink" title="测试步骤"></a>测试步骤</h2><ul>
<li><p>启动游戏后，在右上角的 UWA 窗口选择测试模式。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/8.png" alt="set Mode"><br>Direct Mode 点击后，按钮会变绿，并自动关闭项目。再次启动项目后，会自动进入上一次选择的模式，可以用来测试项目启动时的性能。</p>
</li>
<li><p>点击 start 开启采集, 此 UI 可随意拖动<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/9.png" alt="start">  </p>
</li>
<li><p>点击 stop 停止采集<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/10.png" alt="start">  </p>
</li>
<li><p>打开 UWA_tools 上传测试数据，可选择上传至 online 也可以上传 local server</p>
</li>
</ul>
<h3 id="上传-online-9"><a href="#上传-online-9" class="headerlink" title="上传 online"></a>上传 online</h3><ul>
<li>在 UWA_Tools 工具下选择要上传的数据，选择 Online ，选择目标项目或者新建项目。点击提交数据</li>
<li>打开 uwa 官网，进入 GOT_Oline 选项，选择上传的项目进行查看</li>
</ul>
<h3 id="上传本地服务器-9"><a href="#上传本地服务器-9" class="headerlink" title="上传本地服务器"></a>上传本地服务器</h3><p>如果没钱上传 online 也可以通过设置 local server 上传到本地服务器进行查看</p>
<ul>
<li>选择 GOT ，点击提交数据，</li>
<li>在本地服务器也就是 UnityEditor 中进行查看。</li>
</ul>
<p>local server 设置<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020-6-3/4.png" alt="set Mode"><br>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-8"><a href="#数据分析-8" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-8"><a href="#用例1-8" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-8"><a href="#基本情况-8" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-8"><a href="#CPU情况-8" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-8"><a href="#GPU情况-8" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-8"><a href="#内存情况-8" class="headerlink" title="内存情况"></a>内存情况</h3><p>点击 WIFI 运行。ip 地址是自动获取的本机地址，在 UWA_Tools 中输入服务器的地址（注意不需要输入端口）, 测试通过后即可提交数据<br>如果地址连接不上也可进入目标平台的资源管理器中找到对应数据复制到本地服务器的保存目录下。</p>
<ul>
<li>本地服务器保存地址在 Assets 同级下的 TestData 目录内</li>
<li>目标平台测试数据地址在 UWA-DataCenter/ProfileData 内</li>
</ul>
<h1 id="数据分析-9"><a href="#数据分析-9" class="headerlink" title="数据分析"></a>数据分析</h1><p>待更新</p>
<h2 id="用例1-9"><a href="#用例1-9" class="headerlink" title="用例1"></a>用例1</h2><p>用例简述</p>
<h3 id="基本情况-9"><a href="#基本情况-9" class="headerlink" title="基本情况"></a>基本情况</h3><h3 id="CPU情况-9"><a href="#CPU情况-9" class="headerlink" title="CPU情况"></a>CPU情况</h3><h3 id="GPU情况-9"><a href="#GPU情况-9" class="headerlink" title="GPU情况"></a>GPU情况</h3><h3 id="内存情况-9"><a href="#内存情况-9" class="headerlink" title="内存情况"></a>内存情况</h3>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 总结</title>
    <url>/2019/03/07/Unity/</url>
    <content><![CDATA[<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><ul>
<li>C# <ul>
<li>装箱，拆箱</li>
</ul>
</li>
<li>C++<ul>
<li>内存管理</li>
</ul>
</li>
<li>Lua <ul>
<li>class 实现，原表</li>
</ul>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>美术资源：<ul>
<li>纹理压缩，不同格式的纹理进入内存后的体积不一样，针对应用场景进行更加精细的格式控制。   </li>
<li>UI 上使用公用元素，复用资源。多使用九宫格，减少图片尺寸</li>
<li>网格缩减, 需要展示更多细节的提高面数，离摄像机比较远的使用少的面数，或者使用贴图实现</li>
<li>动画文件优化, 浮点精度减少，关闭缩放</li>
</ul>
</li>
<li>对象：<ul>
<li>对象池复用对象</li>
<li>大尺寸对象的销毁策略优化</li>
</ul>
</li>
<li>脚本：<ul>
<li>销毁闲置脚本（不怎么需要处理）</li>
</ul>
</li>
</ul>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul>
<li>C# GC <ul>
<li>引用计数</li>
</ul>
</li>
<li>Lua GC<ul>
<li>引用计数</li>
<li>GC 步长设定(设定策略）</li>
<li>资料：<br><a href="https://blog.codingnow.com/2011/03/lua_gc_1.html" target="_blank" rel="noopener">https://blog.codingnow.com/2011/03/lua_gc_1.html</a><br><a href="https://blog.codingnow.com/2011/03/lua_gc_2.html" target="_blank" rel="noopener">https://blog.codingnow.com/2011/03/lua_gc_2.html</a><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3></li>
</ul>
</li>
<li>Lua 热更,通过版本文件修改 url</li>
<li>IL2CPP,性能比较高<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3></li>
<li>yeild return new WaitForSeconds(3)</li>
<li>异步编程<br>do something<br>yeild return request()<h3 id="C-C-插件"><a href="#C-C-插件" class="headerlink" title="C/C++插件"></a>C/C++插件</h3></li>
<li>JAVA <-> JNI <-> C/C++ 桥接 <-> CLR</-></-></-></li>
<li>IOS <-> OC <-> CLR</-></-></li>
</ul>
<h3 id="CLR-Common-Language-Runtime"><a href="#CLR-Common-Language-Runtime" class="headerlink" title="CLR(Common Language Runtime)"></a>CLR(Common Language Runtime)</h3><ul>
<li>资料：<a href="http://www.cnblogs.com/skynet/archive/2010/05/17/1737028.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/05/17/1737028.html</a></li>
<li>在 CLR 监管下的运行程序属于 “托管”(managed)代码</li>
<li>直接在裸机上运行的应用或者组件属于”非托管”(unmanaged)代码</li>
</ul>
<h3 id="Unity-API"><a href="#Unity-API" class="headerlink" title="Unity API"></a>Unity API</h3><ul>
<li>gameobject.getComponent</li>
<li>transform</li>
<li>resource</li>
<li>collider</li>
<li>animator</li>
<li>animation</li>
<li>animationclip</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>TCP,UDP  可靠性区别</li>
<li>弱网环境的处理, 保证数据的一致性<ul>
<li>有状态同步，服务器保存玩家的所有状态信息</li>
<li>帧同步, 按帧率推进状态</li>
</ul>
</li>
</ul>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><ul>
<li>渲染管线:<br>顶点 -&gt; 几何 -&gt; 片段 - &gt; 栅格 -&gt; Ztest,Blend -&gt; 后处理</li>
<li>物理碰撞的策略:<ul>
<li>精细化的选择不同的碰撞体</li>
<li>合理的分层控制碰撞范围</li>
<li>少用，或者不用连续碰撞检测</li>
</ul>
</li>
<li>Batch:<ul>
<li>TextureAtlas</li>
<li>静态 batch，资源 build 阶段, 合并物体。<br>优势：不消耗计算资源<br>劣势：包体增大（生成资源文件用来描述合并后的物体）</li>
<li>动态 batch 运行时，forward render ,CPU 合并 物体<br>优势：灵活<br>劣势：消耗计算资源切且，U3D 中对一次 batch 的定点数有限制 900 个，对于有透明物体的情况下，不能很好的执行合批。（透明物体有严格的渲染顺序控制）</li>
<li>运行时合批: 调用 Mesh.CombineMeshes 方法合并物体</li>
</ul>
</li>
<li>纹理格式:</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>MVC<br>老生常谈的一个东西了，在业务逻辑的编写上要注意合理的拆分数据与操作逻辑，View 这一层一般都是由第三方的 UI 框架搭建，结构都很内聚。核心在于实现数据驱动。</li>
<li>UI<ul>
<li>FariyGUI</li>
<li>UGUI</li>
</ul>
</li>
<li>面向对象<ul>
<li>多使用组合，避免使用继承。</li>
<li>业务逻辑上继承的越多，维护越困难。</li>
<li>多使用方法操作数据</li>
<li>业务数据结构要足够元,才能更好的应对迭代变化, 变化的部分放入方法中。</li>
</ul>
</li>
</ul>
<h2 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h2><ul>
<li>UI 解决方案<ul>
<li>锚点缩放</li>
<li>按最小尺寸设计布局</li>
</ul>
</li>
<li>shader<ul>
<li>针对低端机器编写</li>
</ul>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>代码(CPU): </p>
<ul>
<li>减少业务层的复杂逻辑，运算量大的使用 C# 执行，避免使用 Lua</li>
</ul>
<p>渲染(GPU):</p>
<ul>
<li>少用实时光照</li>
<li>shader 优化性能</li>
<li>LOD 技术</li>
<li>遮挡剔除技术</li>
<li>合理的 batch</li>
</ul>
<p>纹理上要避免使用 2048 ，手机端是 CPU 和 GPU 共用一个总线，带宽有限。</p>
<h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><ul>
<li>点乘<br>|a|*|b|cos0</li>
<li>叉乘<br>多项式的矩阵表达</li>
<li>SQT 矩阵<br>特殊 4x4 矩阵用来表达 缩放，旋转，平移</li>
<li>四元数<br>选择的另外一种描述方式<br>优点:<ul>
<li>可以表达旋转的增量, 进行平滑的插值</li>
<li>没有万向节锁</li>
<li>选择方向反向，直接取反四元数即可</li>
<li>旋转轴可以是任意向量</li>
</ul>
</li>
<li>欧拉旋转<br>优点：容易理解<br>缺点：有方向节锁，无法实现平滑的插值</li>
</ul>
<hr>
<p>参考列表：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/10693fee70a5" target="_blank" rel="noopener">https://www.jianshu.com/p/10693fee70a5</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity性能检查</title>
    <url>/2020/06/08/Unity%E6%80%A7%E8%83%BD%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h1><p>Unity Profile                    </p>
<h1 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h1><p>内城切换至指挥官界面                        </p>
<h1 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h1><ul>
<li>加入开始标签  startSwitchScene                        </li>
<li>加入结束标签 SwitchSceneComplete                        <h2 id="获得流程帧区间"><a href="#获得流程帧区间" class="headerlink" title="获得流程帧区间"></a>获得流程帧区间</h2>| Sample | 帧 |<br>| :— | :—- |<br>| StartSwtichScene | 68  |<br>| SwitchSceneComplete | 71 |</li>
</ul>
<p>整个流程帧数合计 3 帧  </p>
<blockquote>
<p>总耗时: 310.62 + 96.62 + 16.53 + 760.59 = 1184.36(ms)</p>
</blockquote>
<h2 id="新增自定义-Sample"><a href="#新增自定义-Sample" class="headerlink" title="新增自定义 Sample"></a>新增自定义 Sample</h2><p>检查代码逻辑，这三帧的操作可以归类为以下情况</p>
<ul>
<li>开始切换<br>Sample: StartSwitchScene</li>
<li>显示 loading ,加载 UIPackage<br>Sample: ShowLoadUI  </li>
<li>离开当前场景<br>Sample: SceneBase.LeaveScene<br>Sample: Lua Call scene hide</li>
<li>加载完毕</li>
<li>离开场景完毕，清理内存<br>Sample: ClearMemory  </li>
<li>进入新场景<br>Sample: SceneBase.EnterScene<br>Sample: Lua Call scene show  </li>
<li>场景切换完成<br>Sample: Lua Call scene change<br>Sample: EnterSceneComplete  </li>
</ul>
<h2 id="逐帧分析"><a href="#逐帧分析" class="headerlink" title="逐帧分析"></a>逐帧分析</h2><h3 id="峰值帧为第-71-帧"><a href="#峰值帧为第-71-帧" class="headerlink" title="峰值帧为第 71 帧"></a>峰值帧为第 71 帧</h3><p>详情如下<br><img src="/2020/06/08/Unity性能检查/1.png" class="71帧"></p>
<h3 id="函数耗时排序-TOP-5"><a href="#函数耗时排序-TOP-5" class="headerlink" title="函数耗时排序 TOP 5"></a>函数耗时排序 TOP 5</h3><table>
<thead>
<tr>
<th style="text-align:left">Sample</th>
<th style="text-align:left">Time(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Lua Call Scene Change</td>
<td style="text-align:left">328.17</td>
</tr>
<tr>
<td style="text-align:left">Loading.ReadObject</td>
<td style="text-align:left">193.53</td>
</tr>
<tr>
<td style="text-align:left">WaitFrameClearMemory(Coroutine:MoveNext)</td>
<td style="text-align:left">111.43</td>
</tr>
<tr>
<td style="text-align:left">StartSwitchScene</td>
<td style="text-align:left">92</td>
</tr>
<tr>
<td style="text-align:left">GC.Collect</td>
<td style="text-align:left">29.17</td>
</tr>
</tbody>
</table>
<p>综合峰值和排序, 得出结论:<br>热点数据存在 Lua 响应 Scene Change 事件的调用<br>ReadObject 为正常情况，可忽略。 第三条为 Lua 的 GC ，时长可接受<br>StartSwitchScene 数值有点高，添加更详细的 Sample 发现音频部分加载时长可能存在异常，但是时长还能接受，优先级不高。<br><img src="/2020/06/08/Unity性能检查/2.png" class="详情"></p>
<h2 id="热点分析"><a href="#热点分析" class="headerlink" title="热点分析"></a>热点分析</h2><p>待续</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>performance analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/04/08/sort/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW2AUgXzAEVU1vdS3ek726.gif" alt="avatar"></p>
<p>每一轮，从数组头部开始，每两个元素比较大小按大小方向进行交换，直到数组末尾。然后不断的重复这个过程。</p>
<blockquote>
<p><strong>数量优化</strong>：每 n 轮比较，数组末尾 n 个元素都是确定的，不需要再进行比较。<br><strong>提前中断</strong>： 在一轮比较中，如果未发生元素交换，说明这个数组已经排序好了，可以中断排序。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasChange</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++ ) &#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; nums.length - <span class="number">1</span> - i ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> tmp = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasChange) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间"><a href="#算法的空间" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW-AJFICAFSirGa8QjY019.gif" alt="avatar"><br>不断的将未排序的元素插入已排序的数组内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++) &#123;</span><br><span class="line">        current = nums[i]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current &gt; nums[j]) &#123;</span><br><span class="line">                nums[j] = current;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-1"><a href="#算法的空间-1" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiXKAR7hcAFhCcVK5jAM221.gif" alt="avatar"></p>
<p>核心思路是把大问题分解成两个或者多个子问题，然后再不断的划分下去直到问题能直接解决, 原始问题的解就是子问题的合并。</p>
<p>把数组不断分解成左右两个子数组，直到只剩单个元素，然后再进行排序合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums, lo , hi</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 问题到最小子集了</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mid = lo + int((hi - lo) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 分成两个子问题</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    sort(nums, mid, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子问题</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">nums, lo ,mid, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy = nums.clone();</span><br><span class="line">    <span class="keyword">var</span> k = lo, i = lo, j = mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(copy[i] &lt; copy[j]) &#123;</span><br><span class="line">            nums[k] = copy[i];</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(copy[j] &lt; copy[i]) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(i &gt; mid) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++ ;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(j &gt; hi) &#123;</span><br><span class="line">            nums[k] = copy[i]</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>合并是需要拷贝原数组，所以是 O(n)</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于规模为 n 的问题来说，每次都是分解成 n / 2 的问题，直到规模为 1 ，类似一个二叉树的结构。二叉树的平均深度是 log(n), 所以需要进行 log(n) 层的划分，每一层都要进行一次合并，合并的元素是所有的元素规模为 n ，也就是 O(n) 的复杂度。 那么真题的复杂度就是 O(nlogn)</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>在分治思想上再进一步优化的就是快速排序，在数组中挑选一个基准值，分解成较大和较小的两个子数组，然后以此继续分解子数组直到问题规模为1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums,int lo, int hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = partiton(nums, lo, hi)</span><br><span class="line">    sort(nums, lo , p - <span class="number">1</span>)</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partiton</span>(<span class="params">nums, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = swap(nums,random(lo, hi), hi)</span><br><span class="line">    <span class="keyword">var</span> i,j</span><br><span class="line">    <span class="keyword">for</span>(i = lo , j  = lo, j &lt; hi ; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[hi]) &#123;</span><br><span class="line">            swap(nums, i , j);</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i , j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为不需要合并操作，只采用交换，所以只要 O(1)</p>
<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间上和归并re排序一样是分成了 logn 层， 每一层都要进行 n - 1 次比较，所以复杂度是 O(nlogn)</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/2B/CgotOV2IiXqAM6cFAFNa8qMI_JU260.gif" alt="avatar"></p>
<p>和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。</p>
<p>拓扑排序的前提是：  </p>
<ol>
<li>图必须没有环</li>
<li>图必须是有向图</li>
</ol>
<p>统计每个顶点的前驱（入度）, 选择入度为 0 的顶点输出。删除此顶点以及以此顶点为起点的有向边。更新顶点前驱，再次选择入度为 0 的顶点输出、剪边。 持续下去直到最后一个顶点。</p>
<p>算法实现上，核心点是对图的搜索。图的搜索算法分广度搜索和深度搜索。</p>
<h2 id="算法的稳定性"><a href="#算法的稳定性" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><ul>
<li>冒泡排序<br>每次排序都只是相邻元素交换位置，即使元素相等，但是在交换过程中先后顺序并不会发生变化。算法是稳定的</li>
<li>插入排序<br>插入排序每次都是插入一个有序数组，也不会改变元素的先后关系，算法是稳定的</li>
<li>归并排序<br>规模为 1 的子问题中，元素的稳定性不会收到破坏。在两个有序数组合并时,我们可以设置两个元素相等时，永远是前一个子数组的数子在前面，这样就保证了排序的稳定。</li>
<li>快速排序<br>在一次划分大小数组结束时，会对 i 和 j 两个元素进行交换。这个交换过程会破坏稳定性。</li>
</ul>
<p>每一轮，从数组头部开始，每两个元素比较大小按大小方向进行交换，直到数组末尾。然后不断的重复这个过程。</p>
<blockquote>
<p><strong>数量优化</strong>：每 n 轮比较，数组末尾 n 个元素都是确定的，不需要再进行比较。<br><strong>提前中断</strong>： 在一轮比较中，如果未发生元素交换，说明这个数组已经排序好了，可以中断排序。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasChange</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++ ) &#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; nums.length - <span class="number">1</span> - i ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> tmp = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasChange) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-2"><a href="#算法的空间-2" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="冒泡排序-2"><a href="#冒泡排序-2" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW2AUgXzAEVU1vdS3ek726.gif" alt="avatar"></p>
<p>每一轮，从数组头部开始，每两个元素比较大小按大小方向进行交换，直到数组末尾。然后不断的重复这个过程。</p>
<blockquote>
<p><strong>数量优化</strong>：每 n 轮比较，数组末尾 n 个元素都是确定的，不需要再进行比较。<br><strong>提前中断</strong>： 在一轮比较中，如果未发生元素交换，说明这个数组已经排序好了，可以中断排序。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasChange</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++ ) &#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; nums.length - <span class="number">1</span> - i ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> tmp = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasChange) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-3"><a href="#算法的空间-3" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="插入排序-2"><a href="#插入排序-2" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW-AJFICAFSirGa8QjY019.gif" alt="avatar"><br>不断的将未排序的元素插入已排序的数组内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++) &#123;</span><br><span class="line">        current = nums[i]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current &gt; nums[j]) &#123;</span><br><span class="line">                nums[j] = current;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-4"><a href="#算法的空间-4" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiXKAR7hcAFhCcVK5jAM221.gif" alt="avatar"></p>
<p>核心思路是把大问题分解成两个或者多个子问题，然后再不断的划分下去直到问题能直接解决, 原始问题的解就是子问题的合并。</p>
<p>把数组不断分解成左右两个子数组，直到只剩单个元素，然后再进行排序合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums, lo , hi</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 问题到最小子集了</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mid = lo + int((hi - lo) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 分成两个子问题</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    sort(nums, mid, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子问题</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">nums, lo ,mid, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy = nums.clone();</span><br><span class="line">    <span class="keyword">var</span> k = lo, i = lo, j = mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(copy[i] &lt; copy[j]) &#123;</span><br><span class="line">            nums[k] = copy[i];</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(copy[j] &lt; copy[i]) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(i &gt; mid) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++ ;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(j &gt; hi) &#123;</span><br><span class="line">            nums[k] = copy[i]</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>合并是需要拷贝原数组，所以是 O(n)</p>
<h3 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于规模为 n 的问题来说，每次都是分解成 n / 2 的问题，直到规模为 1 ，类似一个二叉树的结构。二叉树的平均深度是 log(n), 所以需要进行 log(n) 层的划分，每一层都要进行一次合并，合并的元素是所有的元素规模为 n ，也就是 O(n) 的复杂度。 那么真题的复杂度就是 O(nlogn)</p>
<h2 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h2><p>在分治思想上再进一步优化的就是快速排序，在数组中挑选一个基准值，分解成较大和较小的两个子数组，然后以此继续分解子数组直到问题规模为1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums,int lo, int hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = partiton(nums, lo, hi)</span><br><span class="line">    sort(nums, lo , p - <span class="number">1</span>)</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partiton</span>(<span class="params">nums, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = swap(nums,random(lo, hi), hi)</span><br><span class="line">    <span class="keyword">var</span> i,j</span><br><span class="line">    <span class="keyword">for</span>(i = lo , j  = lo, j &lt; hi ; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[hi]) &#123;</span><br><span class="line">            swap(nums, i , j);</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i , j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为不需要合并操作，只采用交换，所以只要 O(1)</p>
<h3 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间上和归并re排序一样是分成了 logn 层， 每一层都要进行 n - 1 次比较，所以复杂度是 O(nlogn)</p>
<h2 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/2B/CgotOV2IiXqAM6cFAFNa8qMI_JU260.gif" alt="avatar"></p>
<p>和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。</p>
<p>拓扑排序的前提是：  </p>
<ol>
<li>图必须没有环</li>
<li>图必须是有向图</li>
</ol>
<p>统计每个顶点的前驱（入度）, 选择入度为 0 的顶点输出。删除此顶点以及以此顶点为起点的有向边。更新顶点前驱，再次选择入度为 0 的顶点输出、剪边。 持续下去直到最后一个顶点。</p>
<p>算法实现上，核心点是对图的搜索。图的搜索算法分广度搜索和深度搜索。</p>
<h2 id="算法的稳定性-1"><a href="#算法的稳定性-1" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><ul>
<li>冒泡排序<br>每次排序都只是相邻元素交换位置，即使元素相等，但是在交换过程中先后顺序并不会发生变化。算法是稳定的</li>
<li>插入排序<br>插入排序每次都是插入一个有序数组，也不会改变元素的先后关系，算法是稳定的</li>
<li>归并排序<br>规模为 1 的子问题中，元素的稳定性不会收到破坏。在两个有序数组合并时,我们可以设置两个元素相等时，永远是前一个子数组的数子在前面，这样就保证了排序的稳定。</li>
<li>快速排序<br>在一次划分大小数组结束时，会对 i 和 j 两个元素进行交换。这个交换过程会破坏稳定性。</li>
</ul>
<p>不断的将未排序的元素插入已排序的数组内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++) &#123;</span><br><span class="line">        current = nums[i]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current &gt; nums[j]) &#123;</span><br><span class="line">                nums[j] = current;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-5"><a href="#算法的空间-5" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="归并排序-2"><a href="#归并排序-2" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="冒泡排序-3"><a href="#冒泡排序-3" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW2AUgXzAEVU1vdS3ek726.gif" alt="avatar"></p>
<p>每一轮，从数组头部开始，每两个元素比较大小按大小方向进行交换，直到数组末尾。然后不断的重复这个过程。</p>
<blockquote>
<p><strong>数量优化</strong>：每 n 轮比较，数组末尾 n 个元素都是确定的，不需要再进行比较。<br><strong>提前中断</strong>： 在一轮比较中，如果未发生元素交换，说明这个数组已经排序好了，可以中断排序。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasChange</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++ ) &#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; nums.length - <span class="number">1</span> - i ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> tmp = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasChange) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-6"><a href="#算法的空间-6" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="插入排序-3"><a href="#插入排序-3" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW-AJFICAFSirGa8QjY019.gif" alt="avatar"><br>不断的将未排序的元素插入已排序的数组内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++) &#123;</span><br><span class="line">        current = nums[i]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current &gt; nums[j]) &#123;</span><br><span class="line">                nums[j] = current;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-7"><a href="#算法的空间-7" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="归并排序-3"><a href="#归并排序-3" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiXKAR7hcAFhCcVK5jAM221.gif" alt="avatar"></p>
<p>核心思路是把大问题分解成两个或者多个子问题，然后再不断的划分下去直到问题能直接解决, 原始问题的解就是子问题的合并。</p>
<p>把数组不断分解成左右两个子数组，直到只剩单个元素，然后再进行排序合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums, lo , hi</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 问题到最小子集了</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mid = lo + int((hi - lo) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 分成两个子问题</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    sort(nums, mid, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子问题</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">nums, lo ,mid, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy = nums.clone();</span><br><span class="line">    <span class="keyword">var</span> k = lo, i = lo, j = mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(copy[i] &lt; copy[j]) &#123;</span><br><span class="line">            nums[k] = copy[i];</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(copy[j] &lt; copy[i]) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(i &gt; mid) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++ ;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(j &gt; hi) &#123;</span><br><span class="line">            nums[k] = copy[i]</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>合并是需要拷贝原数组，所以是 O(n)</p>
<h3 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于规模为 n 的问题来说，每次都是分解成 n / 2 的问题，直到规模为 1 ，类似一个二叉树的结构。二叉树的平均深度是 log(n), 所以需要进行 log(n) 层的划分，每一层都要进行一次合并，合并的元素是所有的元素规模为 n ，也就是 O(n) 的复杂度。 那么真题的复杂度就是 O(nlogn)</p>
<h2 id="快速排序-2"><a href="#快速排序-2" class="headerlink" title="快速排序"></a>快速排序</h2><p>在分治思想上再进一步优化的就是快速排序，在数组中挑选一个基准值，分解成较大和较小的两个子数组，然后以此继续分解子数组直到问题规模为1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums,int lo, int hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = partiton(nums, lo, hi)</span><br><span class="line">    sort(nums, lo , p - <span class="number">1</span>)</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partiton</span>(<span class="params">nums, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = swap(nums,random(lo, hi), hi)</span><br><span class="line">    <span class="keyword">var</span> i,j</span><br><span class="line">    <span class="keyword">for</span>(i = lo , j  = lo, j &lt; hi ; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[hi]) &#123;</span><br><span class="line">            swap(nums, i , j);</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i , j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-5"><a href="#空间复杂度-5" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为不需要合并操作，只采用交换，所以只要 O(1)</p>
<h3 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间上和归并re排序一样是分成了 logn 层， 每一层都要进行 n - 1 次比较，所以复杂度是 O(nlogn)</p>
<h2 id="拓扑排序-2"><a href="#拓扑排序-2" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/2B/CgotOV2IiXqAM6cFAFNa8qMI_JU260.gif" alt="avatar"></p>
<p>和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。</p>
<p>拓扑排序的前提是：  </p>
<ol>
<li>图必须没有环</li>
<li>图必须是有向图</li>
</ol>
<p>统计每个顶点的前驱（入度）, 选择入度为 0 的顶点输出。删除此顶点以及以此顶点为起点的有向边。更新顶点前驱，再次选择入度为 0 的顶点输出、剪边。 持续下去直到最后一个顶点。</p>
<p>算法实现上，核心点是对图的搜索。图的搜索算法分广度搜索和深度搜索。</p>
<h2 id="算法的稳定性-2"><a href="#算法的稳定性-2" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><ul>
<li>冒泡排序<br>每次排序都只是相邻元素交换位置，即使元素相等，但是在交换过程中先后顺序并不会发生变化。算法是稳定的</li>
<li>插入排序<br>插入排序每次都是插入一个有序数组，也不会改变元素的先后关系，算法是稳定的</li>
<li>归并排序<br>规模为 1 的子问题中，元素的稳定性不会收到破坏。在两个有序数组合并时,我们可以设置两个元素相等时，永远是前一个子数组的数子在前面，这样就保证了排序的稳定。</li>
<li>快速排序<br>在一次划分大小数组结束时，会对 i 和 j 两个元素进行交换。这个交换过程会破坏稳定性。</li>
</ul>
<p>核心思路是把大问题分解成两个或者多个子问题，然后再不断的划分下去直到问题能直接解决, 原始问题的解就是子问题的合并。</p>
<p>把数组不断分解成左右两个子数组，直到只剩单个元素，然后再进行排序合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums, lo , hi</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 问题到最小子集了</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mid = lo + int((hi - lo) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 分成两个子问题</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    sort(nums, mid, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子问题</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">nums, lo ,mid, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy = nums.clone();</span><br><span class="line">    <span class="keyword">var</span> k = lo, i = lo, j = mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(copy[i] &lt; copy[j]) &#123;</span><br><span class="line">            nums[k] = copy[i];</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(copy[j] &lt; copy[i]) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(i &gt; mid) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++ ;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(j &gt; hi) &#123;</span><br><span class="line">            nums[k] = copy[i]</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-6"><a href="#空间复杂度-6" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>合并是需要拷贝原数组，所以是 O(n)</p>
<h3 id="时间复杂度-14"><a href="#时间复杂度-14" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于规模为 n 的问题来说，每次都是分解成 n / 2 的问题，直到规模为 1 ，类似一个二叉树的结构。二叉树的平均深度是 log(n), 所以需要进行 log(n) 层的划分，每一层都要进行一次合并，合并的元素是所有的元素规模为 n ，也就是 O(n) 的复杂度。 那么真题的复杂度就是 O(nlogn)</p>
<h2 id="快速排序-3"><a href="#快速排序-3" class="headerlink" title="快速排序"></a>快速排序</h2><p>在分治思想上再进一步优化的就是快速排序，在数组中挑选一个基准值，分解成较大和较小的两个子数组，然后以此继续分解子数组直到问题规模为1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums,int lo, int hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = partiton(nums, lo, hi)</span><br><span class="line">    sort(nums, lo , p - <span class="number">1</span>)</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partiton</span>(<span class="params">nums, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = swap(nums,random(lo, hi), hi)</span><br><span class="line">    <span class="keyword">var</span> i,j</span><br><span class="line">    <span class="keyword">for</span>(i = lo , j  = lo, j &lt; hi ; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[hi]) &#123;</span><br><span class="line">            swap(nums, i , j);</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i , j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-7"><a href="#空间复杂度-7" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为不需要合并操作，只采用交换，所以只要 O(1)</p>
<h3 id="时间复杂度-15"><a href="#时间复杂度-15" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间上和归并re排序一样是分成了 logn 层， 每一层都要进行 n - 1 次比较，所以复杂度是 O(nlogn)</p>
<h2 id="拓扑排序-3"><a href="#拓扑排序-3" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="冒泡排序-4"><a href="#冒泡排序-4" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW2AUgXzAEVU1vdS3ek726.gif" alt="avatar"></p>
<p>每一轮，从数组头部开始，每两个元素比较大小按大小方向进行交换，直到数组末尾。然后不断的重复这个过程。</p>
<blockquote>
<p><strong>数量优化</strong>：每 n 轮比较，数组末尾 n 个元素都是确定的，不需要再进行比较。<br><strong>提前中断</strong>： 在一轮比较中，如果未发生元素交换，说明这个数组已经排序好了，可以中断排序。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasChange</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++ ) &#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; nums.length - <span class="number">1</span> - i ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> tmp = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasChange) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-8"><a href="#算法的空间-8" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-16"><a href="#时间复杂度-16" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="插入排序-4"><a href="#插入排序-4" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW-AJFICAFSirGa8QjY019.gif" alt="avatar"><br>不断的将未排序的元素插入已排序的数组内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++) &#123;</span><br><span class="line">        current = nums[i]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current &gt; nums[j]) &#123;</span><br><span class="line">                nums[j] = current;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法的空间-9"><a href="#算法的空间-9" class="headerlink" title="算法的空间"></a>算法的空间</h3><p>复杂度上是 o(1)， </p>
<h3 id="时间复杂度-17"><a href="#时间复杂度-17" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最佳：正序数组，需要 n-1 次比较，复杂度为 O(n) 。</li>
<li>最坏：逆序数组，需要 n * (n - 1) /  2 次比较，复杂度为 O(n<sup>2</sup>) 。</li>
</ul>
<h2 id="归并排序-4"><a href="#归并排序-4" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiXKAR7hcAFhCcVK5jAM221.gif" alt="avatar"></p>
<p>核心思路是把大问题分解成两个或者多个子问题，然后再不断的划分下去直到问题能直接解决, 原始问题的解就是子问题的合并。</p>
<p>把数组不断分解成左右两个子数组，直到只剩单个元素，然后再进行排序合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums, lo , hi</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 问题到最小子集了</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mid = lo + int((hi - lo) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 分成两个子问题</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    sort(nums, mid, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子问题</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">nums, lo ,mid, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy = nums.clone();</span><br><span class="line">    <span class="keyword">var</span> k = lo, i = lo, j = mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(copy[i] &lt; copy[j]) &#123;</span><br><span class="line">            nums[k] = copy[i];</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(copy[j] &lt; copy[i]) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(i &gt; mid) &#123;</span><br><span class="line">            nums[k] = copy[j]</span><br><span class="line">            k ++ ;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif(j &gt; hi) &#123;</span><br><span class="line">            nums[k] = copy[i]</span><br><span class="line">            k ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-8"><a href="#空间复杂度-8" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>合并是需要拷贝原数组，所以是 O(n)</p>
<h3 id="时间复杂度-18"><a href="#时间复杂度-18" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于规模为 n 的问题来说，每次都是分解成 n / 2 的问题，直到规模为 1 ，类似一个二叉树的结构。二叉树的平均深度是 log(n), 所以需要进行 log(n) 层的划分，每一层都要进行一次合并，合并的元素是所有的元素规模为 n ，也就是 O(n) 的复杂度。 那么真题的复杂度就是 O(nlogn)</p>
<h2 id="快速排序-4"><a href="#快速排序-4" class="headerlink" title="快速排序"></a>快速排序</h2><p>在分治思想上再进一步优化的就是快速排序，在数组中挑选一个基准值，分解成较大和较小的两个子数组，然后以此继续分解子数组直到问题规模为1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums,int lo, int hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = partiton(nums, lo, hi)</span><br><span class="line">    sort(nums, lo , p - <span class="number">1</span>)</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partiton</span>(<span class="params">nums, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = swap(nums,random(lo, hi), hi)</span><br><span class="line">    <span class="keyword">var</span> i,j</span><br><span class="line">    <span class="keyword">for</span>(i = lo , j  = lo, j &lt; hi ; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[hi]) &#123;</span><br><span class="line">            swap(nums, i , j);</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i , j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间复杂度-9"><a href="#空间复杂度-9" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为不需要合并操作，只采用交换，所以只要 O(1)</p>
<h3 id="时间复杂度-19"><a href="#时间复杂度-19" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间上和归并re排序一样是分成了 logn 层， 每一层都要进行 n - 1 次比较，所以复杂度是 O(nlogn)</p>
<h2 id="拓扑排序-4"><a href="#拓扑排序-4" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="http://s0.lgstatic.com/i/image2/M01/91/2B/CgotOV2IiXqAM6cFAFNa8qMI_JU260.gif" alt="avatar"></p>
<p>和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。</p>
<p>拓扑排序的前提是：  </p>
<ol>
<li>图必须没有环</li>
<li>图必须是有向图</li>
</ol>
<p>统计每个顶点的前驱（入度）, 选择入度为 0 的顶点输出。删除此顶点以及以此顶点为起点的有向边。更新顶点前驱，再次选择入度为 0 的顶点输出、剪边。 持续下去直到最后一个顶点。</p>
<p>算法实现上，核心点是对图的搜索。图的搜索算法分广度搜索和深度搜索。</p>
<h2 id="算法的稳定性-3"><a href="#算法的稳定性-3" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><ul>
<li>冒泡排序<br>每次排序都只是相邻元素交换位置，即使元素相等，但是在交换过程中先后顺序并不会发生变化。算法是稳定的</li>
<li>插入排序<br>插入排序每次都是插入一个有序数组，也不会改变元素的先后关系，算法是稳定的</li>
<li>归并排序<br>规模为 1 的子问题中，元素的稳定性不会收到破坏。在两个有序数组合并时,我们可以设置两个元素相等时，永远是前一个子数组的数子在前面，这样就保证了排序的稳定。</li>
<li>快速排序<br>在一次划分大小数组结束时，会对 i 和 j 两个元素进行交换。这个交换过程会破坏稳定性。</li>
</ul>
<p>和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。</p>
<p>拓扑排序的前提是：  </p>
<ol>
<li>图必须没有环</li>
<li>图必须是有向图</li>
</ol>
<p>统计每个顶点的前驱（入度）, 选择入度为 0 的顶点输出。删除此顶点以及以此顶点为起点的有向边。更新顶点前驱，再次选择入度为 0 的顶点输出、剪边。 持续下去直到最后一个顶点。</p>
<p>算法实现上，核心点是对图的搜索。图的搜索算法分广度搜索和深度搜索。</p>
<h2 id="算法的稳定性-4"><a href="#算法的稳定性-4" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><ul>
<li>冒泡排序<br>每次排序都只是相邻元素交换位置，即使元素相等，但是在交换过程中先后顺序并不会发生变化。算法是稳定的</li>
<li>插入排序<br>插入排序每次都是插入一个有序数组，也不会改变元素的先后关系，算法是稳定的</li>
<li>归并排序<br>规模为 1 的子问题中，元素的稳定性不会收到破坏。在两个有序数组合并时,我们可以设置两个元素相等时，永远是前一个子数组的数子在前面，这样就保证了排序的稳定。</li>
<li>快速排序<br>在一次划分大小数组结束时，会对 i 和 j 两个元素进行交换。这个交换过程会破坏稳定性。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity序列化</title>
    <url>/2020/05/18/unity%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>序列化是为了将对象存储（或传输）到内存、数据库或文件中，把对象状态转化为一组字节的过程</p>
<h1 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h1><p>序列化是为了将对象存储（或传输）到内存、数据库或文件中，把对象状态转化为一组字节的过程</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/1.png" alt="avatar"></p>
<h1 id="Unity-如何序列化"><a href="#Unity-如何序列化" class="headerlink" title="Unity 如何序列化"></a>Unity 如何序列化</h1><p>Unity 中 UnityEngine.Object 类提供序列化能力，任何继承自它的类（MonoBehaviour,ScriptableObject）， 都可被序列化。 其中大部分使用都是隐形的，开发中不需要在意。</p>
<h2 id="MonoBehavior-编写"><a href="#MonoBehavior-编写" class="headerlink" title="MonoBehavior 编写"></a>MonoBehavior 编写</h2><p>可被序列化的字段必须符合以下几点：</p>
<ul>
<li>设为public，或者添加[SerializeField]属性</li>
<li>不要设为static</li>
<li>不要设为const</li>
<li>不要设为readonly</li>
<li>字段类型必须是可以序列化的类型</li>
</ul>
<h2 id="哪些类型可以序列化？"><a href="#哪些类型可以序列化？" class="headerlink" title="哪些类型可以序列化？"></a>哪些类型可以序列化？</h2><ul>
<li>来自UntiyEngine.Object的对象引用</li>
<li>有 [Serializable] 属性的自定义非抽象类</li>
<li>基础数据类型（int，float，double，bool，string等等）</li>
<li>可序列化的数组Array字段类型</li>
<li>可序列化的泛型列表List<t>字段类型<br>结构体</t></li>
</ul>
<blockquote>
<p>一个很常见的不可被序列化的数据结构：<strong>Dictionaries</strong>，即使把它们声明为公有并且有 [SerializeField] 属性。在开发游戏时要记住这点。</p>
</blockquote>
<h2 id="自定义序列化类型"><a href="#自定义序列化类型" class="headerlink" title="自定义序列化类型"></a>自定义序列化类型</h2><p>添加 [System.Serializable] 修饰符</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BehaviorNode obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="会出现的问题"><a href="#会出现的问题" class="headerlink" title="会出现的问题"></a>会出现的问题</h3><ul>
<li>任然依赖于 MonoBehaviour 并且需要 GameObject 才可存在</li>
<li>无法支持多态，对一个基类数组添加三个同样的子类对象，序列化后是三个基类对象。</li>
<li>耦合引用, 对一个泛型列表添加同一个对象三次，序列化后是三个不同的对象。</li>
<li>递归声明<br>自定义类型的序列化不支持空引用，在递归引用时，会陷入循环创建的的死循环。 unity 为解决这个问题，限制了最大层深度为 7 层。</li>
</ul>
<h3 id="解决方法-ScriptableObjects"><a href="#解决方法-ScriptableObjects" class="headerlink" title="解决方法 ScriptableObjects"></a>解决方法 ScriptableObjects</h3><ul>
<li>可存储为 xx.asset 资源，不再依托于 GameObject</li>
<li>ScriptableObjects 继承自 Unity.Object， 在序列化时创建的是对象的引用。</li>
</ul>
<h1 id="Unity-Edtior-对序列化数据的使用"><a href="#Unity-Edtior-对序列化数据的使用" class="headerlink" title="Unity Edtior 对序列化数据的使用"></a>Unity Edtior 对序列化数据的使用</h1><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/2.png" alt="avatar"></p>
<p>Editor 通过修改序列化数据修改以及显示目标对象</p>
<h2 id="操作-API"><a href="#操作-API" class="headerlink" title="操作 API"></a>操作 API</h2><p><strong>EditorWIndow</strong>  </p>
<blockquote>
<p>创建一个窗口</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditStartWindow</span>: <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    Editor editor;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Behavior/Edit"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EditStartWindow window = EditorWindow.CreateInstance&lt;EditStartWindow&gt;();</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Open"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Inspector</strong></p>
<blockquote>
<p>定制 Class 在 Inspector 中的显示</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(BehaviorRunTime))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BehaviorRunTimeEditor</span>: <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Run"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BehaviorRunTime runTime = target <span class="keyword">as</span> BehaviorRunTime;</span><br><span class="line">            runTime.Invoke(<span class="string">"Run"</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CustomPropertyDrawer</strong>  </p>
<blockquote>
<p>自定义字段的显示方案</p>
</blockquote>
<ul>
<li><p>PropertyDrawer<br> 对自定义属性的字段调用此方法渲染</p>
</li>
<li><p>DecoratorDrawer<br> 以装饰模式进行渲染，区别是</p>
<ul>
<li>不会改变检查器的原始行为，而是扩展它 </li>
<li>一个属性上能加不止一个DecoratorDrawer </li>
<li>数组或List上加DecoratorDrawer只会对第一个起作用。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/3.png" alt="avatar"></li>
</ul>
</li>
</ul>
<h1 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h1><h2 id="不可序列化的类型"><a href="#不可序列化的类型" class="headerlink" title="不可序列化的类型"></a>不可序列化的类型</h2><ul>
<li>高维数组低维化，底层使用一维数组来替代</li>
<li>字典把 Key 和 Value 各种存储为 List , 运行时用字典，序列化时用数组</li>
</ul>
<h2 id="自定义序列化接口"><a href="#自定义序列化接口" class="headerlink" title="自定义序列化接口"></a>自定义序列化接口</h2><p><strong>ISerializationCallbackReceiver</strong><br>Unity 提供的一个接口，通过实现 OnBeforeSerialize 和 OnAfterDeserialize 使的原本不能被序列化成功的类可以被加工成合格的类型。</p>
<h2 id="Net-序列化机制"><a href="#Net-序列化机制" class="headerlink" title=".Net 序列化机制"></a>.Net 序列化机制</h2><p>通过实现 ISerializable 自定义序列化和反序列化过程</p>
<blockquote>
<p>另外还有其它的解决方案：<br>Json Xml yaml 和 二进制</p>
</blockquote>
<h2 id="新的版本支持-2019-x"><a href="#新的版本支持-2019-x" class="headerlink" title="新的版本支持 2019.x"></a>新的版本支持 2019.x</h2><p>新增 [SerializeReference]  支持对引用类型序列化，支持接口以及抽象类</p>
<p>PS：</p>
<ul>
<li>引用的类必须是可序列化类型</li>
<li>引用值无法在 UnityEngine.Object 实例间进行共享</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用 Unity 的序列化时必须明确了解那些字段能够被序列化，从而减少因为序列化，反序列化后对象数据不一致导致的问题。</p>
<h1 id="Unity-如何序列化-1"><a href="#Unity-如何序列化-1" class="headerlink" title="Unity 如何序列化"></a>Unity 如何序列化</h1><p>Unity 中 UnityEngine.Object 类提供序列化能力，任何继承自它的类（MonoBehaviour,ScriptableObject）， 都可被序列化。 其中大部分使用都是隐形的，开发中不需要在意。</p>
<h2 id="MonoBehavior-编写-1"><a href="#MonoBehavior-编写-1" class="headerlink" title="MonoBehavior 编写"></a>MonoBehavior 编写</h2><p>可被序列化的字段必须符合以下几点：</p>
<ul>
<li>设为public，或者添加[SerializeField]属性</li>
<li>不要设为static</li>
<li>不要设为const</li>
<li>不要设为readonly</li>
<li>字段类型必须是可以序列化的类型</li>
</ul>
<h2 id="哪些类型可以序列化？-1"><a href="#哪些类型可以序列化？-1" class="headerlink" title="哪些类型可以序列化？"></a>哪些类型可以序列化？</h2><ul>
<li>来自UntiyEngine.Object的对象引用</li>
<li>有 [Serializable] 属性的自定义非抽象类</li>
<li>基础数据类型（int，float，double，bool，string等等）</li>
<li>可序列化的数组Array字段类型</li>
<li>可序列化的泛型列表List<t>字段类型<br>结构体</t></li>
</ul>
<blockquote>
<p>一个很常见的不可被序列化的数据结构：<strong>Dictionaries</strong>，即使把它们声明为公有并且有 [SerializeField] 属性。在开发游戏时要记住这点。</p>
</blockquote>
<h2 id="自定义序列化类型-1"><a href="#自定义序列化类型-1" class="headerlink" title="自定义序列化类型"></a>自定义序列化类型</h2><p>添加 [System.Serializable] 修饰符</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BehaviorNode obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="会出现的问题-1"><a href="#会出现的问题-1" class="headerlink" title="会出现的问题"></a>会出现的问题</h3><ul>
<li>任然依赖于 MonoBehaviour 并且需要 GameObject 才可存在</li>
<li>无法支持多态，对一个基类数组添加三个同样的子类对象，序列化后是三个基类对象。</li>
<li>耦合引用, 对一个泛型列表添加同一个对象三次，序列化后是三个不同的对象。</li>
<li>递归声明<br>自定义类型的序列化不支持空引用，在递归引用时，会陷入循环创建的的死循环。 unity 为解决这个问题，限制了最大层深度为 7 层。</li>
</ul>
<h3 id="解决方法-ScriptableObjects-1"><a href="#解决方法-ScriptableObjects-1" class="headerlink" title="解决方法 ScriptableObjects"></a>解决方法 ScriptableObjects</h3><ul>
<li>可存储为 xx.asset 资源，不再依托于 GameObject</li>
<li>ScriptableObjects 继承自 Unity.Object， 在序列化时创建的是对象的引用。</li>
</ul>
<h1 id="Unity-Edtior-对序列化数据的使用-1"><a href="#Unity-Edtior-对序列化数据的使用-1" class="headerlink" title="Unity Edtior 对序列化数据的使用"></a>Unity Edtior 对序列化数据的使用</h1><h1 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h1><p>序列化是为了将对象存储（或传输）到内存、数据库或文件中，把对象状态转化为一组字节的过程</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/1.png" alt="avatar"></p>
<h1 id="Unity-如何序列化-2"><a href="#Unity-如何序列化-2" class="headerlink" title="Unity 如何序列化"></a>Unity 如何序列化</h1><p>Unity 中 UnityEngine.Object 类提供序列化能力，任何继承自它的类（MonoBehaviour,ScriptableObject）， 都可被序列化。 其中大部分使用都是隐形的，开发中不需要在意。</p>
<h2 id="MonoBehavior-编写-2"><a href="#MonoBehavior-编写-2" class="headerlink" title="MonoBehavior 编写"></a>MonoBehavior 编写</h2><p>可被序列化的字段必须符合以下几点：</p>
<ul>
<li>设为public，或者添加[SerializeField]属性</li>
<li>不要设为static</li>
<li>不要设为const</li>
<li>不要设为readonly</li>
<li>字段类型必须是可以序列化的类型</li>
</ul>
<h2 id="哪些类型可以序列化？-2"><a href="#哪些类型可以序列化？-2" class="headerlink" title="哪些类型可以序列化？"></a>哪些类型可以序列化？</h2><ul>
<li>来自UntiyEngine.Object的对象引用</li>
<li>有 [Serializable] 属性的自定义非抽象类</li>
<li>基础数据类型（int，float，double，bool，string等等）</li>
<li>可序列化的数组Array字段类型</li>
<li>可序列化的泛型列表List<t>字段类型<br>结构体</t></li>
</ul>
<blockquote>
<p>一个很常见的不可被序列化的数据结构：<strong>Dictionaries</strong>，即使把它们声明为公有并且有 [SerializeField] 属性。在开发游戏时要记住这点。</p>
</blockquote>
<h2 id="自定义序列化类型-2"><a href="#自定义序列化类型-2" class="headerlink" title="自定义序列化类型"></a>自定义序列化类型</h2><p>添加 [System.Serializable] 修饰符</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BehaviorNode obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="会出现的问题-2"><a href="#会出现的问题-2" class="headerlink" title="会出现的问题"></a>会出现的问题</h3><ul>
<li>任然依赖于 MonoBehaviour 并且需要 GameObject 才可存在</li>
<li>无法支持多态，对一个基类数组添加三个同样的子类对象，序列化后是三个基类对象。</li>
<li>耦合引用, 对一个泛型列表添加同一个对象三次，序列化后是三个不同的对象。</li>
<li>递归声明<br>自定义类型的序列化不支持空引用，在递归引用时，会陷入循环创建的的死循环。 unity 为解决这个问题，限制了最大层深度为 7 层。</li>
</ul>
<h3 id="解决方法-ScriptableObjects-2"><a href="#解决方法-ScriptableObjects-2" class="headerlink" title="解决方法 ScriptableObjects"></a>解决方法 ScriptableObjects</h3><ul>
<li>可存储为 xx.asset 资源，不再依托于 GameObject</li>
<li>ScriptableObjects 继承自 Unity.Object， 在序列化时创建的是对象的引用。</li>
</ul>
<h1 id="Unity-Edtior-对序列化数据的使用-2"><a href="#Unity-Edtior-对序列化数据的使用-2" class="headerlink" title="Unity Edtior 对序列化数据的使用"></a>Unity Edtior 对序列化数据的使用</h1><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/2.png" alt="avatar"></p>
<p>Editor 通过修改序列化数据修改以及显示目标对象</p>
<h2 id="操作-API-1"><a href="#操作-API-1" class="headerlink" title="操作 API"></a>操作 API</h2><p><strong>EditorWIndow</strong>  </p>
<blockquote>
<p>创建一个窗口</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditStartWindow</span>: <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    Editor editor;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Behavior/Edit"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EditStartWindow window = EditorWindow.CreateInstance&lt;EditStartWindow&gt;();</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Open"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Inspector</strong></p>
<blockquote>
<p>定制 Class 在 Inspector 中的显示</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(BehaviorRunTime))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BehaviorRunTimeEditor</span>: <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Run"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BehaviorRunTime runTime = target <span class="keyword">as</span> BehaviorRunTime;</span><br><span class="line">            runTime.Invoke(<span class="string">"Run"</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CustomPropertyDrawer</strong>  </p>
<blockquote>
<p>自定义字段的显示方案</p>
</blockquote>
<ul>
<li><p>PropertyDrawer<br> 对自定义属性的字段调用此方法渲染</p>
</li>
<li><p>DecoratorDrawer<br> 以装饰模式进行渲染，区别是</p>
<ul>
<li>不会改变检查器的原始行为，而是扩展它 </li>
<li>一个属性上能加不止一个DecoratorDrawer </li>
<li>数组或List上加DecoratorDrawer只会对第一个起作用。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/3.png" alt="avatar"></li>
</ul>
</li>
</ul>
<h1 id="问题的解决-1"><a href="#问题的解决-1" class="headerlink" title="问题的解决"></a>问题的解决</h1><h2 id="不可序列化的类型-1"><a href="#不可序列化的类型-1" class="headerlink" title="不可序列化的类型"></a>不可序列化的类型</h2><ul>
<li>高维数组低维化，底层使用一维数组来替代</li>
<li>字典把 Key 和 Value 各种存储为 List , 运行时用字典，序列化时用数组</li>
</ul>
<h2 id="自定义序列化接口-1"><a href="#自定义序列化接口-1" class="headerlink" title="自定义序列化接口"></a>自定义序列化接口</h2><p><strong>ISerializationCallbackReceiver</strong><br>Unity 提供的一个接口，通过实现 OnBeforeSerialize 和 OnAfterDeserialize 使的原本不能被序列化成功的类可以被加工成合格的类型。</p>
<h2 id="Net-序列化机制-1"><a href="#Net-序列化机制-1" class="headerlink" title=".Net 序列化机制"></a>.Net 序列化机制</h2><p>通过实现 ISerializable 自定义序列化和反序列化过程</p>
<blockquote>
<p>另外还有其它的解决方案：<br>Json Xml yaml 和 二进制</p>
</blockquote>
<h2 id="新的版本支持-2019-x-1"><a href="#新的版本支持-2019-x-1" class="headerlink" title="新的版本支持 2019.x"></a>新的版本支持 2019.x</h2><p>新增 [SerializeReference]  支持对引用类型序列化，支持接口以及抽象类</p>
<p>PS：</p>
<ul>
<li>引用的类必须是可序列化类型</li>
<li>引用值无法在 UnityEngine.Object 实例间进行共享</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>在使用 Unity 的序列化时必须明确了解那些字段能够被序列化，从而减少因为序列化，反序列化后对象数据不一致导致的问题。</p>
<p>Editor 通过修改序列化数据修改以及显示目标对象</p>
<h2 id="操作-API-2"><a href="#操作-API-2" class="headerlink" title="操作 API"></a>操作 API</h2><p><strong>EditorWIndow</strong>  </p>
<blockquote>
<p>创建一个窗口</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditStartWindow</span>: <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    Editor editor;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Behavior/Edit"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EditStartWindow window = EditorWindow.CreateInstance&lt;EditStartWindow&gt;();</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Open"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Inspector</strong></p>
<blockquote>
<p>定制 Class 在 Inspector 中的显示</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(BehaviorRunTime))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BehaviorRunTimeEditor</span>: <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Run"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BehaviorRunTime runTime = target <span class="keyword">as</span> BehaviorRunTime;</span><br><span class="line">            runTime.Invoke(<span class="string">"Run"</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CustomPropertyDrawer</strong>  </p>
<blockquote>
<p>自定义字段的显示方案</p>
</blockquote>
<ul>
<li><p>PropertyDrawer<br> 对自定义属性的字段调用此方法渲染</p>
</li>
<li><p>DecoratorDrawer<br> 以装饰模式进行渲染，区别是</p>
<ul>
<li>不会改变检查器的原始行为，而是扩展它 </li>
<li>一个属性上能加不止一个DecoratorDrawer </li>
<li>数组或List上加DecoratorDrawer只会对第一个起作用。</li>
</ul>
</li>
</ul>
<h1 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h1><p>序列化是为了将对象存储（或传输）到内存、数据库或文件中，把对象状态转化为一组字节的过程</p>
<p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/1.png" alt="avatar"></p>
<h1 id="Unity-如何序列化-3"><a href="#Unity-如何序列化-3" class="headerlink" title="Unity 如何序列化"></a>Unity 如何序列化</h1><p>Unity 中 UnityEngine.Object 类提供序列化能力，任何继承自它的类（MonoBehaviour,ScriptableObject）， 都可被序列化。 其中大部分使用都是隐形的，开发中不需要在意。</p>
<h2 id="MonoBehavior-编写-3"><a href="#MonoBehavior-编写-3" class="headerlink" title="MonoBehavior 编写"></a>MonoBehavior 编写</h2><p>可被序列化的字段必须符合以下几点：</p>
<ul>
<li>设为public，或者添加[SerializeField]属性</li>
<li>不要设为static</li>
<li>不要设为const</li>
<li>不要设为readonly</li>
<li>字段类型必须是可以序列化的类型</li>
</ul>
<h2 id="哪些类型可以序列化？-3"><a href="#哪些类型可以序列化？-3" class="headerlink" title="哪些类型可以序列化？"></a>哪些类型可以序列化？</h2><ul>
<li>来自UntiyEngine.Object的对象引用</li>
<li>有 [Serializable] 属性的自定义非抽象类</li>
<li>基础数据类型（int，float，double，bool，string等等）</li>
<li>可序列化的数组Array字段类型</li>
<li>可序列化的泛型列表List<t>字段类型<br>结构体</t></li>
</ul>
<blockquote>
<p>一个很常见的不可被序列化的数据结构：<strong>Dictionaries</strong>，即使把它们声明为公有并且有 [SerializeField] 属性。在开发游戏时要记住这点。</p>
</blockquote>
<h2 id="自定义序列化类型-3"><a href="#自定义序列化类型-3" class="headerlink" title="自定义序列化类型"></a>自定义序列化类型</h2><p>添加 [System.Serializable] 修饰符</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BehaviorNode obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="会出现的问题-3"><a href="#会出现的问题-3" class="headerlink" title="会出现的问题"></a>会出现的问题</h3><ul>
<li>任然依赖于 MonoBehaviour 并且需要 GameObject 才可存在</li>
<li>无法支持多态，对一个基类数组添加三个同样的子类对象，序列化后是三个基类对象。</li>
<li>耦合引用, 对一个泛型列表添加同一个对象三次，序列化后是三个不同的对象。</li>
<li>递归声明<br>自定义类型的序列化不支持空引用，在递归引用时，会陷入循环创建的的死循环。 unity 为解决这个问题，限制了最大层深度为 7 层。</li>
</ul>
<h3 id="解决方法-ScriptableObjects-3"><a href="#解决方法-ScriptableObjects-3" class="headerlink" title="解决方法 ScriptableObjects"></a>解决方法 ScriptableObjects</h3><ul>
<li>可存储为 xx.asset 资源，不再依托于 GameObject</li>
<li>ScriptableObjects 继承自 Unity.Object， 在序列化时创建的是对象的引用。</li>
</ul>
<h1 id="Unity-Edtior-对序列化数据的使用-3"><a href="#Unity-Edtior-对序列化数据的使用-3" class="headerlink" title="Unity Edtior 对序列化数据的使用"></a>Unity Edtior 对序列化数据的使用</h1><p><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/2.png" alt="avatar"></p>
<p>Editor 通过修改序列化数据修改以及显示目标对象</p>
<h2 id="操作-API-3"><a href="#操作-API-3" class="headerlink" title="操作 API"></a>操作 API</h2><p><strong>EditorWIndow</strong>  </p>
<blockquote>
<p>创建一个窗口</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditStartWindow</span>: <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    Editor editor;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Behavior/Edit"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EditStartWindow window = EditorWindow.CreateInstance&lt;EditStartWindow&gt;();</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Open"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Inspector</strong></p>
<blockquote>
<p>定制 Class 在 Inspector 中的显示</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(BehaviorRunTime))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BehaviorRunTimeEditor</span>: <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Run"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BehaviorRunTime runTime = target <span class="keyword">as</span> BehaviorRunTime;</span><br><span class="line">            runTime.Invoke(<span class="string">"Run"</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CustomPropertyDrawer</strong>  </p>
<blockquote>
<p>自定义字段的显示方案</p>
</blockquote>
<ul>
<li><p>PropertyDrawer<br> 对自定义属性的字段调用此方法渲染</p>
</li>
<li><p>DecoratorDrawer<br> 以装饰模式进行渲染，区别是</p>
<ul>
<li>不会改变检查器的原始行为，而是扩展它 </li>
<li>一个属性上能加不止一个DecoratorDrawer </li>
<li>数组或List上加DecoratorDrawer只会对第一个起作用。<br><img src="https://raw.githubusercontent.com/dupouyer/dupouyer.github.io/hexo/source/_posts/img/2020_5_18/3.png" alt="avatar"></li>
</ul>
</li>
</ul>
<h1 id="问题的解决-2"><a href="#问题的解决-2" class="headerlink" title="问题的解决"></a>问题的解决</h1><h2 id="不可序列化的类型-2"><a href="#不可序列化的类型-2" class="headerlink" title="不可序列化的类型"></a>不可序列化的类型</h2><ul>
<li>高维数组低维化，底层使用一维数组来替代</li>
<li>字典把 Key 和 Value 各种存储为 List , 运行时用字典，序列化时用数组</li>
</ul>
<h2 id="自定义序列化接口-2"><a href="#自定义序列化接口-2" class="headerlink" title="自定义序列化接口"></a>自定义序列化接口</h2><p><strong>ISerializationCallbackReceiver</strong><br>Unity 提供的一个接口，通过实现 OnBeforeSerialize 和 OnAfterDeserialize 使的原本不能被序列化成功的类可以被加工成合格的类型。</p>
<h2 id="Net-序列化机制-2"><a href="#Net-序列化机制-2" class="headerlink" title=".Net 序列化机制"></a>.Net 序列化机制</h2><p>通过实现 ISerializable 自定义序列化和反序列化过程</p>
<blockquote>
<p>另外还有其它的解决方案：<br>Json Xml yaml 和 二进制</p>
</blockquote>
<h2 id="新的版本支持-2019-x-2"><a href="#新的版本支持-2019-x-2" class="headerlink" title="新的版本支持 2019.x"></a>新的版本支持 2019.x</h2><p>新增 [SerializeReference]  支持对引用类型序列化，支持接口以及抽象类</p>
<p>PS：</p>
<ul>
<li>引用的类必须是可序列化类型</li>
<li>引用值无法在 UnityEngine.Object 实例间进行共享</li>
</ul>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>在使用 Unity 的序列化时必须明确了解那些字段能够被序列化，从而减少因为序列化，反序列化后对象数据不一致导致的问题。</p>
<h1 id="问题的解决-3"><a href="#问题的解决-3" class="headerlink" title="问题的解决"></a>问题的解决</h1><h2 id="不可序列化的类型-3"><a href="#不可序列化的类型-3" class="headerlink" title="不可序列化的类型"></a>不可序列化的类型</h2><ul>
<li>高维数组低维化，底层使用一维数组来替代</li>
<li>字典把 Key 和 Value 各种存储为 List , 运行时用字典，序列化时用数组</li>
</ul>
<h2 id="自定义序列化接口-3"><a href="#自定义序列化接口-3" class="headerlink" title="自定义序列化接口"></a>自定义序列化接口</h2><p><strong>ISerializationCallbackReceiver</strong><br>Unity 提供的一个接口，通过实现 OnBeforeSerialize 和 OnAfterDeserialize 使的原本不能被序列化成功的类可以被加工成合格的类型。</p>
<h2 id="Net-序列化机制-3"><a href="#Net-序列化机制-3" class="headerlink" title=".Net 序列化机制"></a>.Net 序列化机制</h2><p>通过实现 ISerializable 自定义序列化和反序列化过程</p>
<blockquote>
<p>另外还有其它的解决方案：<br>Json Xml yaml 和 二进制</p>
</blockquote>
<h2 id="新的版本支持-2019-x-3"><a href="#新的版本支持-2019-x-3" class="headerlink" title="新的版本支持 2019.x"></a>新的版本支持 2019.x</h2><p>新增 [SerializeReference]  支持对引用类型序列化，支持接口以及抽象类</p>
<p>PS：</p>
<ul>
<li>引用的类必须是可序列化类型</li>
<li>引用值无法在 UnityEngine.Object 实例间进行共享</li>
</ul>
<h1 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h1><p>在使用 Unity 的序列化时必须明确了解那些字段能够被序列化，从而减少因为序列化，反序列化后对象数据不一致导致的问题。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>场景切换性能分析</title>
    <url>/2020/06/10/%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><table>
<thead>
<tr>
<th style="text-align:left">工具</th>
<th style="text-align:left">平台</th>
<th style="text-align:left">加载</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UnityProfile</td>
<td style="text-align:left">android</td>
<td style="text-align:left">AssetDataBase</td>
</tr>
</tbody>
</table>
<h2 id="游戏表现"><a href="#游戏表现" class="headerlink" title="游戏表现"></a>游戏表现</h2><p>从其它场景切换至内城场景时会有 1-2 s 左右的卡顿</p>
<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>获取切换区间， CPU 消耗详情，检查峰值帧。<br>Loading.ReadObject 函数耗时占比过高，初步判断热点问题在于加载。</p>
<h2 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h2><p>查看内城代码，进入场景时会触发 IEnumerator<float>DelayEnterScene() 的流程控制函数。<br>针对函数内部流程分别增加采样函数 step1 ~ step 4，并对其中 Lua 部分的调用增加 Lua Call Main_City_Scene_Init 的采样函数</float></p>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>耗时异常发生在 Step2 以及 step3 结果如下图<br><img src="/2020/06/10/场景切换性能分析/2.png"><br><img src="/2020/06/10/场景切换性能分析/1.png"></p>
<p>结合代码查看：  </p>
<ul>
<li>Step2 内城在同步加载场景基础 Obejct</li>
<li>Step3 模型中的 Collider 创建一些动态创建的建筑。</li>
</ul>
<h2 id="加载分析"><a href="#加载分析" class="headerlink" title="加载分析"></a>加载分析</h2><p>增加加载耗时计数，统计场景切换时，每个 res 的加载耗时，结果如下。<br><img src="/2020/06/10/场景切换性能分析/3.png"><br><img src="/2020/06/10/场景切换性能分析/4.png"><br><img src="/2020/06/10/场景切换性能分析/5.png"></p>
<p>总耗时：837.7312(ms)<br>Step2 Loading.ReadObject = 574.48<br>Step3 Loading.ReadObject = 229.03  </p>
<p><strong>对比可知。耗时问题在于场景 prefab 的加载。</strong></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>performance analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义渲染管线(SRP)</title>
    <url>/2021/06/20/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-SRP/</url>
    <content><![CDATA[<h1 id="SRP-介绍"><a href="#SRP-介绍" class="headerlink" title="SRP 介绍"></a>SRP 介绍</h1><p>Unity 的 Scriptable Render Pipeline (SRP) 是一项允许您通过 C# 脚本控制渲染的功能。 在此基础上，Unity 官方提供了通用渲染管线 (URP) 和高清渲染管线 (HDRP) 两种开箱即用的渲染管线。</p>
<h1 id="管线创建"><a href="#管线创建" class="headerlink" title="管线创建"></a>管线创建</h1><h2 id="Create-PiplineAsset"><a href="#Create-PiplineAsset" class="headerlink" title="Create PiplineAsset"></a>Create PiplineAsset</h2><p>自定义管线 Asset，定义个人 Pipeline 类。</p>
<h1 id="自定义管线流程"><a href="#自定义管线流程" class="headerlink" title="自定义管线流程"></a>自定义管线流程</h1><p>在开放出来的 Render 方法中制订流程</p>
<h2 id="Cull"><a href="#Cull" class="headerlink" title="Cull"></a>Cull</h2><p>获得相机裁剪结果</p>
<h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h2><p>渲染流程<br>CommandBuff 渲染命令缓冲区</p>
<h3 id="DrawRenders"><a href="#DrawRenders" class="headerlink" title="DrawRenders"></a>DrawRenders</h3><p>绘制物体<br>ScriptableRenderContext 定义自定义渲染管线使用的状态和绘图命令。<br>DrawRenderers</p>
<h3 id="DrawSkyBox"><a href="#DrawSkyBox" class="headerlink" title="DrawSkyBox"></a>DrawSkyBox</h3><p>绘制天空盒子</p>
<h3 id="RenderTransparentQueue"><a href="#RenderTransparentQueue" class="headerlink" title="RenderTransparentQueue"></a>RenderTransparentQueue</h3><p>绘制透明通道内的物体</p>
<h3 id="DrawDefaultPipeline"><a href="#DrawDefaultPipeline" class="headerlink" title="DrawDefaultPipeline"></a>DrawDefaultPipeline</h3><p>绘制默认管线，显示失效物体</p>
<h2 id="Post-processing"><a href="#Post-processing" class="headerlink" title="Post-processing"></a>Post-processing</h2><p>后效处理</p>
<h1 id="URP-简析"><a href="#URP-简析" class="headerlink" title="URP 简析"></a>URP 简析</h1><h2 id="特点介绍"><a href="#特点介绍" class="headerlink" title="特点介绍"></a>特点介绍</h2><p>开箱即用，高性能，针对全平台使用。前向渲染</p>
<h2 id="demo-展示"><a href="#demo-展示" class="headerlink" title="demo 展示"></a>demo 展示</h2><p>渲染流程展示</p>
<p>功能对比<br><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.5/manual/universalrp-builtin-feature-comparison.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.5/manual/universalrp-builtin-feature-comparison.html</a></p>
<p>资料：<br><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.5/manual/post-processing-ssao.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.5/manual/post-processing-ssao.html</a></p>
<p><a href="https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.high-definition@7.4/manual/index.html" target="_blank" rel="noopener">https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.high-definition@7.4/manual/index.html</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>SRP</tag>
      </tags>
  </entry>
</search>
